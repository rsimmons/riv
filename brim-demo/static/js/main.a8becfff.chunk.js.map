{"version":3,"sources":["../../riv-runtime/lib/index.js","../../riv-demo-lib/src/index.js","../../riv-snabbdom/src/index.js","State.ts","uid.ts","Compiler.ts","LiveFunction.ts","EditReducer.ts","vendor/fts_fuzzy_match.js","ExpressionChooser.js","themes/Simple.js","ThemePicker.js","Editor.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["Object","defineProperty","exports","value","currentUpdateFrame","ExecutionContext","streamFunc","onRequestUpdate","afterTerminate","this","hookRecordChain","data","cleanup","next","recordCursor","openRecord","updateCount","prototype","update","args","_i","arguments","length","retval","executionContext","previousFrame","apply","Error","poppedFrame","terminate","c","_beginHook","_endHook","_requestUpdate","_setStreamFunc","newStreamFunc","currentBatch","enqueueBatchedUpdate","callback","callbacks","add","getTopUpdatingExecutionContext","useVar","initVal","ctx","record","actualInitVal","Function","current","useRequestUpdate","requestUpdate","useEventReceiver","stream","queue_1","data_1","queue","lastStream","unsubscribe","onValue","push","recordData","subscribe","pop","beginBatch","Set","endBatch","forEach","cb","createNullaryVoidRootExecutionContext","useInitialize","initializer","useEventEmitter","subscribers_1","delete","emit","sub","useDynamic","oru_1","data_2","activeContexts","createContext","useReducer","evts","reducerFunc","initialState","state","evt","useReducers","streamReducerPairs","numStreams","evtCount","streamReducerPairs_1","_a","reducer","useCallbackReducer","action","useCallbackReducers","reducerFuncs","map","useMachine","states","initialTransition","takeTransition","trans","activeContext","newState","newStateArg","newCtx","activeState","activeArgument","data_3","tmpRetval","transition","__webpack_require__","r","__webpack_exports__","d","showString","animationFrameEvts","animationTime","countEvents","mouseClickEvts","mouseDown","mousePosition","random","audioDriver","sampleUpon","everySecond","loadAudioAsArray","integral","expFollow","redCircle","followAtSpeed2d","eventAfter","received","streamMap","changeCount","_Users_russ_proj_riv_packages_brim_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__","_require","_require2","renderDOMAppendedToBody","h","v","vnode","style","border","color","fontSize","padding","marginTop","undefined","toString","reqId","_useEventEmitter","_useEventEmitter2","frameEvts","emitFrame","requestAnimationFrame","onFrame","t","cancelAnimationFrame","latestValue","initialValue","_","performance","now","previousCount","domEvts","eventTarget","type","extra","_useEventEmitter9","_useEventEmitter10","onEvent","e","document","addEventListener","removeEventListener","downEvts","upEvts","inputEvts","inputEvt","_useEventEmitter3","_useEventEmitter4","outputEvts","emitOutput","mapEvts","x","y","repickEvts","Math","generator","createGenerator","generatorCtx","frameCount","sampleRate","_useEventEmitter11","_useEventEmitter12","advanceFrameEvts","emitAdvanceFrameEvt","audioContext","window","AudioContext","webkitAudioContext","scriptNode","createScriptProcessor","onaudioprocess","buffer","outputBuffer","getChannelData","i","frameVal","Number","isNaN","connect","destination","disconnect","close","toSample","uponEvts","_useEventEmitter13","_useEventEmitter14","tickEvts","emitTick","timerId","setInterval","clearInterval","url","pcm","audioCtx","cleanedUp","request","XMLHttpRequest","open","responseType","onload","audioData","response","decodeAudioData","send","abort","integrandFunc","time","accum","prevTime","integrand","targetValue","speedConstant","currentValue","position","radius","p","halfRadius","borderRadius","background","pointerEvents","userSelect","left","top","width","height","target","speed","initial","pos","dt","delta","dist","sqrt","seconds","valueToEmit","_useEventEmitter15","_useEventEmitter16","setTimeout","clearTimeout","previousState","event","f","arr","createFContext","fContexts","s","a","b","count","previous","renderDOMIntoElement","renderDOMIntoSelector","riv_runtime__WEBPACK_IMPORTED_MODULE_0__","patch","init","default","cloneNode","sel","children","text","key","elm","containerElement","savedContainerElement","previousVnode","clonedVnode","innerHTML","elem","createElement","appendChild","containerSelector","querySelector","body","removeChild","isProgramNode","node","isArrayLiteralNode","isApplicationNode","isExpressionNode","isUndefinedExpressionNode","isIntegerLiteralNode","isStreamReferenceNode","isParameterNode","isUserFunctionNode","isNode","isIdentifierNode","isNativeFunctionNode","isFunctionNode","gen32","substring","uid","CompilationError","_Error","classCallCheck","possibleConstructorReturn","getPrototypeOf","inherits","wrapNativeSuper","traverseFromExpression","expression","temporaryMarkedStreamIds","permanentMarkedStreamIds","compiledDefinition","has","streamId","literalStreamValues","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","items","Symbol","iterator","done","err","return","applications","item","targetExpressionNode","derivedLookups","streamIdToNode","get","targetStreamId","functionNode","functionIdToNode","functionId","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","functionArguments","functionArgument","containedDefinitions","compileUserDefinition","definition","parameterStreams","parameters","param","yieldStream","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","expressions","Environment","outer","obj","create","createClass","name","require","SCHEMA_NODES","Program","fields","mainDefinition","Identifier","UndefinedExpression","identifier","IntegerLiteral","ArrayLiteral","StreamReference","Application","Parameter","NativeFunction","signature","jsFunction","UserFunction","functionParameterFunctionIds","SCHEMA_CLASSES","Expression","Any","nodeFromPath","root","path","cur","nodeSplitPath","idx","seg","slice","addExpressionLocalEnvironment","expr","namedStreams","namedFunctions","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","farg","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","addUserFunctionLocalEnvironment","func","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","environmentForSelectedNode","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","nativeFunctions","extFunc","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","addEnvironmentAlongPath","program","selectionPath","equiv","JSON","stringify","HANDLERS","_ref","subpath","newIdx","max","min","newExpressionIdx","_ref2","removeIdx","newNode","objectSpread","concat","toConsumableArray","genuid","deleteDefinitionExpression","_ref3","_ref4","editingSelected","_ref5","trimmedName","trim","_ref6","_ref7","console","log","_ref8","afterIdx","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","newArguments","recursiveReducer","nodeOnPath","nodeInfo","newSelPath","newEditingSelected","handled","indexableNode","_Object$entries","entries","_ref24","_ref21","slicedToArray","fieldName","childNode","recResult","_recResult","n","sp","es","newArr","childNodes","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","arrn","_recResult3","_i2","_HANDLERS","_ref25","_ref23","nt","acts","hfunc","includes","_nodeSplitPath","_nodeSplitPath2","pathBefore","handlerResult","_handlerResult","handlerNewNode","handlerNewSubpath","handlerNewEditingSelected","addStateLookups","Map","_iteratorNormalCompletion17","_didIteratorError17","_iteratorError17","_step17","_iterator17","set","recursiveBuildIdMaps","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_step12","_iterator12","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_step13","_iterator13","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_step14","_iterator14","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_step15","_iterator15","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_step16","_iterator16","recursiveUndefineDanglingStreamRefs","arg","addStateCompiled","oldState","newLiveMain","newCompiledDefinition","message","_ref26","liveMain","context","updateCompiledDefinition","_createLiveFunction","createLiveFunction","initialDefinition","outerStreamEnvironment","outerFunctionEnvironment","activations","activation","streamEnvironment","functionEnvironment","sid","applicationContext","fid","updateContainedDefinition","_createLiveFunction2","sf","updateDef","_activation$current","streamEnv","funcEnv","appCtx","argIds","fargIds","argVals","appVal","newDefinition","oldLiteralMap","newLiteralMap","_ref37","val","_ref38","_loop","_loop2","_ref20","oldAppMap","newAppMap","_ref39","_ref22","_ref40","_loop3","_loop4","_ref27","_ref28","funcId","createNew","oldApp","_oldApp","oldFuncId","oldArgs","arraysShallowEqual","oldDefMap","newDefMap","_ref41","_ref30","def","_ref42","_ref32","_loop5","_ref33","_loop6","_ref35","_ref36","_createLiveFunction3","_createLiveFunction4","nativeFunctionEnvironment","liveStreamFunc","addDerivedState","_recResult4","newProgram","newSelectionPath","functionParameters","_pred","_then","_else","cos","Array","of","jsFunc","mdId","_ref29","fuzzy_match","pattern","str","score","patternIdx","patternLength","strIdx","strLength","prevMatched","prevLower","prevSeparator","bestLetter","bestLower","bestLetterIdx","bestLetterScore","matchedIndices","patternChar","charAt","strChar","patternLower","toLowerCase","strLower","strUpper","toUpperCase","nextMatch","rematch","newScore","formattedStr","lastIdx","substr","fuzzySearch","query","results","_fuzzy_match","_fuzzy_match2","hit","sort","FLOAT_REGEX","generateChoices","mainState","choices","_environmentForSelect","streamSearchResults","result","functionSearchResults","test","Choice","choice","react_default","startsWith","join","ExpressionChooser","dispatch","selectedListElem","useRef","useEffect","scrollIntoView","block","inline","_useState","useState","_useState2","setText","realizeChoice","index","paramName","pn","recomputeDropdownChoices","adjustDropdownIndex","amount","setDropdownState","_useState3","_useState4","dropdownState","className","onChange","newText","onKeyDown","preventDefault","autoFocus","ref","addSelection","selected","cns","generateTheme","expressionGrouping","applicationArguments","functionName","streamArgs","functionArgs","appClass","nameClass","functionExpression","parameterNames","DefinitionExpression","inside","keyedItems","INITIAL_OPTIONS","INITIAL_THEME","Select","keyLabels","selectedKey","label","ThemePicker","options","setOptions","newOptions","keyMap","MOVE_UP","MOVE_DOWN","MOVE_LEFT","MOVE_RIGHT","ZOOM_IN","ZOOM_OUT","TOGGLE_EDIT","EDIT_AFTER","DELETE","BEGIN_EXPRESSION_IDENTIFIER_EDIT","COMMAND_CHARS","CATCH_IN_INPUTS","DispatchContext","SelectedNodeContext","useIsSelected","useContext","FullStateContext","ThemeContext","ProgramView","DefinitionExpressionsView","Fragment","ExpressionView","IdentifierChooser","initialName","onUpdateName","onEndEdit","stopPropagation","ExpressionIdentifierView","IntegerLiteralView","integerLiteral","ArrayLiteralView","arrayLiteral","UndefinedExpressionView","undefinedExpression","StreamReferenceView","streamReference","UserFunctionView","userFunction","ApplicationView","application","NotEditingExpressionView","ExpressionChooser_ExpressionChooser","Editor","_useReducer","_useReducer2","theme","setTheme","editorElem","_useState5","constAutoFocus","focus","previouslyEditingSelected","handlers","k","_Object$keys","keys","index_es","only","tagName","altkey","ctrlKey","metaKey","tabIndex","ThemePicker_ThemePicker","newTheme","Provider","App","Editor_Editor","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a8becfff.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar currentUpdateFrame = null;\n\nvar ExecutionContext =\n/** @class */\nfunction () {\n  function ExecutionContext(streamFunc, onRequestUpdate, afterTerminate) {\n    if (afterTerminate === void 0) {\n      afterTerminate = null;\n    }\n\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      data: null,\n      cleanup: null,\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.openRecord = null;\n    this.updateCount = 0;\n  }\n\n  ExecutionContext.prototype.update = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Push a new update frame onto the update stack for this context\n\n\n    var newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    var retval;\n\n    try {\n      retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn't get to, and something is amiss\n\n      if (this.recordCursor.next) {\n        throw new Error('Did not reach all hook records in update');\n      }\n    } finally {\n      // Pop the top frame from the update stack\n      var poppedFrame = currentUpdateFrame;\n\n      if (!poppedFrame) {\n        throw new Error('Cannot pop update frame because current is null');\n      }\n\n      if (poppedFrame.executionContext !== this) {\n        throw new Error(\"Popped frame from update stack but context did not match\");\n      }\n\n      currentUpdateFrame = poppedFrame.previousFrame;\n    }\n\n    this.updateCount++;\n    return retval;\n  };\n\n  ExecutionContext.prototype.terminate = function () {\n    // NOTE: Might we want to sanity check that this context isn't anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (var c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  };\n\n  ExecutionContext.prototype._beginHook = function () {\n    if (this.openRecord) {\n      throw new Error('This is already an open hook when beginning another');\n    }\n\n    if (!this.recordCursor) {\n      throw new Error();\n    }\n\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error('Expecting to create new hook record in chain, but already present');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: null,\n        cleanup: null,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error('Expecting to find hook record in chain, but not present');\n    }\n\n    this.openRecord = this.recordCursor.next;\n    return this.recordCursor.next;\n  };\n\n  ExecutionContext.prototype._endHook = function () {\n    if (!this.recordCursor) {\n      throw new Error();\n    }\n\n    if (this.openRecord !== this.recordCursor.next) {\n      throw new Error('Hook close does not match open');\n    }\n\n    this.openRecord = null;\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  };\n\n  ExecutionContext.prototype._requestUpdate = function () {\n    this.onRequestUpdate();\n  };\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It's currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  ExecutionContext.prototype._setStreamFunc = function (newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  };\n\n  return ExecutionContext;\n}();\n\nexports.ExecutionContext = ExecutionContext;\nvar currentBatch = null;\n\nfunction beginBatch() {\n  if (currentBatch) {\n    throw new Error('cannot begin batch when one is already active');\n  }\n\n  currentBatch = {\n    callbacks: new Set()\n  };\n}\n\nexports.beginBatch = beginBatch;\n\nfunction endBatch() {\n  if (!currentBatch) {\n    throw new Error('cannot end batch when none is active');\n  }\n\n  currentBatch.callbacks.forEach(function (cb) {\n    cb();\n  });\n  currentBatch = null;\n}\n\nexports.endBatch = endBatch;\n\nfunction enqueueBatchedUpdate(callback) {\n  if (currentBatch) {\n    currentBatch.callbacks.add(callback);\n  } else {\n    // NOTE: If there is no current batch, we just call the callback immediately\n    callback();\n  }\n}\n\nexports.enqueueBatchedUpdate = enqueueBatchedUpdate;\n\nfunction createNullaryVoidRootExecutionContext(streamFunc) {\n  var onRequestUpdate = function onRequestUpdate() {\n    enqueueBatchedUpdate(function () {\n      ctx.update();\n    });\n  };\n\n  var ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n\nexports.createNullaryVoidRootExecutionContext = createNullaryVoidRootExecutionContext;\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error('Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n/**\n * If initVal is a function, it will be called on first update to generate initial value.\n */\n\n\nfunction useVar(initVal) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    var actualInitVal = initVal instanceof Function ? initVal() : initVal;\n    record.data = {\n      current: actualInitVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n\nexports.useVar = useVar;\n/**\n * Why do we need a hook? Why can't we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: function requestUpdate() {\n        ctx._requestUpdate(); // it's important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\n\nexports.useRequestUpdate = useRequestUpdate;\n\nfunction useInitialize(initializer) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer() || null;\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\n\nexports.useInitialize = useInitialize;\n\nfunction useEventEmitter() {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    var subscribers_1 = new Set();\n    var stream = {\n      subscribe: function subscribe(onValue) {\n        subscribers_1.add(onValue);\n        return function () {\n          subscribers_1.delete(onValue);\n        };\n      }\n    };\n\n    var emit = function emit(value) {\n      subscribers_1.forEach(function (sub) {\n        sub(value);\n      });\n    };\n\n    record.data = {\n      stream: stream,\n      emit: emit\n    };\n  }\n\n  ctx._endHook();\n\n  return [record.data.stream, record.data.emit];\n}\n\nexports.useEventEmitter = useEventEmitter;\n\nfunction useEventReceiver(stream) {\n  ;\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    var queue_1 = [];\n    var data_1 = {\n      queue: queue_1,\n      lastStream: null,\n      unsubscribe: null,\n      onValue: function onValue(value) {\n        queue_1.push(value);\n      }\n    };\n    record.data = data_1;\n\n    record.cleanup = function () {\n      if (data_1.unsubscribe) {\n        data_1.unsubscribe();\n      }\n    };\n  }\n\n  var retval;\n  var recordData = record.data;\n\n  if (stream !== recordData.lastStream) {\n    // Stream changed identity\n    // I _think_ we want to disallow this, since semantics are unclear\n    if (recordData.queue.length) {\n      throw new Error('useEventReceiver stream changed, but value is in queue');\n    }\n\n    if (recordData.lastStream) {\n      if (!recordData.unsubscribe) {\n        throw new Error('should not be possible');\n      }\n\n      recordData.unsubscribe();\n      recordData.lastStream = null;\n      recordData.unsubscribe = null;\n    } // TODO: We could validate that it's either undefined or null or a valid stream object\n\n\n    recordData.lastStream = stream;\n\n    if (stream) {\n      recordData.unsubscribe = stream.subscribe(recordData.onValue);\n    }\n  } else {\n    // Stream did not change identity. Check if there is an value in the queue\n    if (recordData.queue.length) {\n      if (recordData.queue.length > 1) {\n        throw new Error('useEventReceiver found more than one enqueued value');\n      }\n\n      var eventValue = recordData.queue.pop(); // assertion is OK because we verified length is 1\n\n      retval = {\n        value: eventValue\n      };\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n\nexports.useEventReceiver = useEventReceiver;\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new \"version\" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    // If no onRequestUpdate is provided, default to requesting update on the current context\n    var oru_1 = onRequestUpdate || function () {\n      ctx._requestUpdate();\n    };\n\n    var data_2 = {\n      // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n      activeContexts: new Set(),\n      // Create \"factory\" function to instantiate new contexts\n      createContext: function createContext() {\n        var ctx = new ExecutionContext(data_2.streamFunc, oru_1, function () {\n          data_2.activeContexts.delete(ctx);\n        });\n        data_2.activeContexts.add(ctx);\n        return ctx;\n      },\n      streamFunc: function streamFunc() {\n        throw new Error('should be unreachable');\n      }\n    };\n    record.data = data_2;\n\n    record.cleanup = function () {\n      data_2.activeContexts.forEach(function (ctx) {\n        return ctx.terminate();\n      });\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n  record.data.activeContexts.forEach(function (ctx) {\n    ctx._setStreamFunc(streamFunc);\n  });\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}\n\nexports.useDynamic = useDynamic;\n/**\n * NOTE: reducerFunc should be pure-pointwise, NOT a stream func\n * If initialState is a function, it will be called on first update to generate initial state.\n */\n\nfunction useReducer(evts, reducerFunc, initialState) {\n  var state = useVar(initialState);\n  var evt = useEventReceiver(evts);\n\n  if (evt) {\n    state.current = reducerFunc(state.current, evt.value);\n  }\n\n  return state.current;\n}\n\nexports.useReducer = useReducer;\n/**\n * NOTE: streamReducerPairs must not change length.\n */\n\nfunction useReducers(streamReducerPairs, initialState) {\n  var state = useVar(initialState);\n  var numStreams = useVar(streamReducerPairs.length);\n\n  if (streamReducerPairs.length !== numStreams.current) {\n    // NOTE: We could allow this with some extra work\n    throw new Error('The number of streams/reducers supplied to useMultiReducer cannot change');\n  } // It's safe to call hook in this loop because we made sure that the length is the same\n\n\n  var evtCount = 0;\n\n  for (var _i = 0, streamReducerPairs_1 = streamReducerPairs; _i < streamReducerPairs_1.length; _i++) {\n    var _a = streamReducerPairs_1[_i],\n        evts = _a[0],\n        reducer = _a[1];\n    var evt = useEventReceiver(evts);\n\n    if (evt) {\n      if (evtCount > 0) {\n        // TODO: We _could_ handle these sequentially.. should we have a flag that says whether to allow or not?\n        throw new Error('useMultiReducer got multiple events, cannot merge');\n      }\n\n      state.current = reducer(state.current, evt.value);\n      evtCount++;\n    }\n  }\n\n  return state.current;\n}\n\nexports.useReducers = useReducers;\n/**\n * NOTE: reducerFunc should be pure-pointwise, NOT a stream func\n * If initialState is a function, it will be called on first update to generate initial state.\n */\n\nfunction useCallbackReducer(reducerFunc, initialState) {\n  var requestUpdate = useRequestUpdate();\n  var state = useVar(initialState); // We cache the callback, though I don't think we really need to?\n\n  var callback = useVar(function () {\n    return function (action) {\n      state.current = reducerFunc(state.current, action);\n      requestUpdate();\n    };\n  });\n  return [state.current, callback.current];\n}\n\nexports.useCallbackReducer = useCallbackReducer;\n\nfunction useCallbackReducers(reducerFuncs, initialState) {\n  var requestUpdate = useRequestUpdate();\n  var state = useVar(initialState);\n  var callbacks = reducerFuncs.map(function (reducerFunc) {\n    return function (action) {\n      state.current = reducerFunc(state.current, action);\n      requestUpdate();\n    };\n  });\n  return [state.current, callbacks];\n}\n\nexports.useCallbackReducers = useCallbackReducers;\n/**\n * TODO: Could/should this take an optional onRequestUpdate parameter?\n */\n\nfunction useMachine(states, initialTransition) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook();\n\n  var takeTransition = function takeTransition(trans) {\n    // If there's an old context, terminate it\n    if (record.data.activeContext) {\n      record.data.activeContext.terminate();\n    }\n\n    var newState = trans[0],\n        newStateArg = trans[1]; // Create a new context and store it in record (but don't update it)\n\n    var newCtx = new ExecutionContext(states[newState], function () {\n      ctx._requestUpdate();\n    });\n    record.data.activeState = newState;\n    record.data.activeContext = newCtx;\n    record.data.activeArgument = newStateArg;\n  };\n\n  if (!record.data) {\n    var data_3 = {\n      activeContext: null\n    };\n    record.data = data_3;\n    takeTransition(initialTransition); // this will set stuff in record.data\n\n    record.cleanup = function () {\n      if (!data_3.activeContext) {\n        throw new Error('should have been initialized');\n      }\n\n      data_3.activeContext.terminate();\n    };\n  }\n\n  var retval;\n\n  while (true) {\n    // Set the state function in the active context (in case it changed)\n    record.data.activeContext._setStreamFunc(states[record.data.activeState]); // Update the active context\n\n\n    var _a = record.data.activeContext.update(record.data.activeArgument),\n        tmpRetval = _a[0],\n        transition = _a[1];\n\n    retval = tmpRetval; // Did the state function return a transition to take?\n\n    if (transition) {\n      takeTransition(transition); // And loop again\n    } else {\n      // There was no transition\n      break;\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n\nexports.useMachine = useMachine;","import _toConsumableArray from \"/Users/russ/proj/riv/packages/brim/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/russ/proj/riv/packages/brim/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _require = require('riv-runtime'),\n    useVar = _require.useVar,\n    useRequestUpdate = _require.useRequestUpdate,\n    useInitialize = _require.useInitialize,\n    useEventEmitter = _require.useEventEmitter,\n    useEventReceiver = _require.useEventReceiver,\n    useDynamic = _require.useDynamic,\n    useReducer = _require.useReducer,\n    useReducers = _require.useReducers;\n\nvar _require2 = require('riv-snabbdom'),\n    renderDOMAppendedToBody = _require2.renderDOMAppendedToBody,\n    h = _require2.h;\n\nexport function showString(v) {\n  var vnode = h('div', {\n    style: {\n      border: '1px solid red',\n      color: 'black',\n      fontSize: '24px',\n      padding: '5px',\n      marginTop: '20px'\n    }\n  }, 'showString: ' + (v === undefined ? '(undefined)' : v.toString()));\n  renderDOMAppendedToBody(vnode);\n}\nexport function animationFrameEvts() {\n  var requestUpdate = useRequestUpdate();\n  var reqId = useVar();\n\n  var _useEventEmitter = useEventEmitter(),\n      _useEventEmitter2 = _slicedToArray(_useEventEmitter, 2),\n      frameEvts = _useEventEmitter2[0],\n      emitFrame = _useEventEmitter2[1];\n\n  useInitialize(function () {\n    var onFrame = function onFrame(t) {\n      emitFrame(0.001 * t);\n      requestUpdate();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return function () {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\n\nfunction latestValue(evts, initialValue) {\n  return useReducer(evts, function (_, value) {\n    return value;\n  }, initialValue);\n}\n\nfunction mapEvts(inputEvts) {\n  var inputEvt = useEventReceiver(inputEvts);\n\n  var _useEventEmitter3 = useEventEmitter(),\n      _useEventEmitter4 = _slicedToArray(_useEventEmitter3, 2),\n      outputEvts = _useEventEmitter4[0],\n      emitOutput = _useEventEmitter4[1];\n\n  if (inputEvt) {\n    emitOutput(inputEvt.value);\n  } // TODO: We don't need to request update since we are already being updated\n\n\n  return outputEvts;\n}\n\nfunction mergeEvts(streams) {\n  var _useEventEmitter5 = useEventEmitter(),\n      _useEventEmitter6 = _slicedToArray(_useEventEmitter5, 2),\n      outputEvts = _useEventEmitter6[0],\n      emitOutput = _useEventEmitter6[1]; // TODO: This is a hack that assumes array length never changes\n\n\n  var evts = _toConsumableArray(streams).map(function (stream) {\n    return useEventReceiver(stream);\n  }).filter(function (e) {\n    return e;\n  });\n\n  if (evts.length > 1) {\n    throw new Error('Failed to merge events since more than one present');\n  } else if (evts.length === 1) {\n    emitOutput(evts[0].value);\n  }\n\n  return outputEvts;\n}\n\nexport function animationTime() {\n  return latestValue(animationFrameEvts(), function () {\n    return 0.001 * performance.now();\n  });\n}\nexport function countEvents(evts) {\n  return useReducer(evts, function (previousCount) {\n    return previousCount + 1;\n  }, 0);\n}\n\nfunction makeAsyncCallback() {\n  var _useEventEmitter7 = useEventEmitter(),\n      _useEventEmitter8 = _slicedToArray(_useEventEmitter7, 2),\n      evts = _useEventEmitter8[0],\n      emit = _useEventEmitter8[1];\n\n  var requestUpdate = useRequestUpdate();\n\n  var callback = function callback() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    emit(args);\n    requestUpdate();\n  };\n\n  return [callback, evts];\n}\n\nfunction domEvts(eventTarget, type, extra) {\n  // TODO: We should cache type/extra\n  var requestUpdate = useRequestUpdate();\n\n  var _useEventEmitter9 = useEventEmitter(),\n      _useEventEmitter10 = _slicedToArray(_useEventEmitter9, 2),\n      evts = _useEventEmitter10[0],\n      emit = _useEventEmitter10[1];\n\n  useInitialize(function () {\n    var onEvent = function onEvent(e) {\n      emit(e);\n      requestUpdate();\n    };\n\n    document.addEventListener(type, onEvent, extra);\n    return function () {\n      // cleanup\n      document.removeEventListener(type, onEvent, extra);\n    };\n  });\n  return evts;\n}\n\nexport function mouseClickEvts() {\n  return domEvts(document, 'mousedown');\n}\nexport function mouseDown() {\n  var downEvts = domEvts(document, 'mousedown');\n  var upEvts = domEvts(document, 'mouseup');\n  return useReducers([[upEvts, function () {\n    return false;\n  }], [downEvts, function () {\n    return true;\n  }]], false); // We can't poll down-ness, so we assume it's initially not down\n}\nexport function mousePosition() {\n  return latestValue(mapEvts(domEvts(document, 'mousemove'), function (e) {\n    return {\n      x: e.clientX || e.pageX,\n      y: e.clientY || e.pageY\n    };\n  }), {\n    x: 0,\n    y: 0\n  });\n}\nexport function random(repickEvts) {\n  return useReducer(repickEvts, function () {\n    return Math.random();\n  }, function () {\n    return Math.random();\n  });\n}\nexport function audioDriver(generator) {\n  var createGenerator = useDynamic(generator);\n  var generatorCtx = useVar();\n  var frameCount = useVar(0);\n  var sampleRate = useVar();\n\n  var _useEventEmitter11 = useEventEmitter(),\n      _useEventEmitter12 = _slicedToArray(_useEventEmitter11, 2),\n      advanceFrameEvts = _useEventEmitter12[0],\n      emitAdvanceFrameEvt = _useEventEmitter12[1];\n\n  useInitialize(function () {\n    generatorCtx.current = createGenerator();\n    var BUFFER_SIZE = 1024;\n    var audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    var scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = function (e) {\n      var buffer = e.outputBuffer.getChannelData(0);\n\n      for (var i = 0; i < buffer.length; i++) {\n        emitAdvanceFrameEvt();\n        var frameVal = generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current);\n\n        if (!frameVal || Number.isNaN(frameVal)) {\n          frameVal = 0;\n        } else if (frameVal > 1) {\n          frameVal = 1;\n        } else if (frameVal < -1) {\n          frameVal = -1;\n        }\n\n        buffer[i] = frameVal;\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return function () {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current); // NOTE: we discard retval\n}\nexport function sampleUpon(toSample, uponEvts, initialValue) {\n  return useReducer(uponEvts, function () {\n    return toSample;\n  }, initialValue);\n}\nexport function everySecond() {\n  var requestUpdate = useRequestUpdate();\n\n  var _useEventEmitter13 = useEventEmitter(),\n      _useEventEmitter14 = _slicedToArray(_useEventEmitter13, 2),\n      tickEvts = _useEventEmitter14[0],\n      emitTick = _useEventEmitter14[1];\n\n  useInitialize(function () {\n    var onInterval = function onInterval() {\n      emitTick();\n      requestUpdate();\n    };\n\n    var timerId = setInterval(onInterval, 1000);\n    return function () {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvts;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\nexport function loadAudioAsArray(url) {\n  var requestUpdate = useRequestUpdate();\n  var pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(function () {\n    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    var cleanedUp = false;\n    var request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = function () {\n      var audioData = request.response;\n      audioCtx.decodeAudioData(audioData, function (buffer) {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return function () {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nexport function integral(integrandFunc, time) {\n  var initialValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var accum = useVar(initialValue);\n  var prevTime = useVar(time);\n  var integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\nexport function expFollow(targetValue, speedConstant, time, initialValue) {\n  return integral(function (currentValue) {\n    return speedConstant * (targetValue - currentValue);\n  }, time, initialValue);\n}\nexport function redCircle(position) {\n  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n  var p = position || {\n    x: 0,\n    y: 0\n  };\n\n  if (radius < 0) {\n    radius = 0;\n  }\n\n  var halfRadius = 0.5 * radius;\n  var vnode = h('div', {\n    style: {\n      position: 'absolute',\n      borderRadius: '50%',\n      background: 'red',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      left: p.x - halfRadius + 'px',\n      top: p.y - halfRadius + 'px',\n      width: radius + 'px',\n      height: radius + 'px'\n    }\n  });\n  renderDOMAppendedToBody(vnode);\n}\nexport function followAtSpeed2d(target, speed, time, initial) {\n  var pos = useVar(initial);\n  var prevTime = useVar(time);\n  var dt = time - prevTime.current;\n  var delta = {\n    x: target.x - pos.current.x,\n    y: target.y - pos.current.y\n  };\n  var dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n\n  if (speed * dt >= dist) {\n    // Jump to target position\n    pos.current = target;\n  } else {\n    // NOTE: We must not mutate pos.current, since we return that\n    pos.current = {\n      x: pos.current.x + dt * speed * delta.x / dist,\n      y: pos.current.y + dt * speed * delta.y / dist\n    };\n  }\n\n  prevTime.current = time;\n  return pos.current;\n}\n/**\n * Note that this _will_ fire in first call if condition starts truthy\n */\n\nfunction eventWhen(condition, valueToEmit) {\n  var prevCondition = useVar(false);\n  var bcond = !!condition;\n  var retval = bcond && !prevCondition.current ? {\n    value: valueToEmit\n  } : undefined;\n  prevCondition.current = bcond;\n  return retval;\n}\n/**\n * Note that seconds argument is only read initially. But valueToEmit is re-read on changes\n */\n\n\nexport function eventAfter(seconds, valueToEmit) {\n  var _useEventEmitter15 = useEventEmitter(),\n      _useEventEmitter16 = _slicedToArray(_useEventEmitter15, 2),\n      evts = _useEventEmitter16[0],\n      emit = _useEventEmitter16[1];\n\n  var value = useVar(valueToEmit);\n  value.current = valueToEmit;\n  useInitialize(function () {\n    var timerId = setTimeout(function () {\n      emit(value.current);\n    }, 1000 * seconds);\n    return function () {\n      clearTimeout(timerId);\n    };\n  });\n  return evts;\n}\nexport function received(evts) {\n  return useReducer(evts, function (previousState, event) {\n    return true;\n  }, false);\n}\n/**\n * F is a stream function that must stay hook-equivalent.\n */\n\nexport function streamMap(f) {\n  var arr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var createFContext = useDynamic(f);\n  var fContexts = useVar([]); // Create or destrooy contexts as needed to match arr length\n\n  while (arr.length > fContexts.current.length) {\n    fContexts.current.push(createFContext());\n  }\n\n  while (arr.length < fContexts.current.length) {\n    var ctx = fContexts.current.pop();\n    ctx.terminate();\n  }\n\n  var outs = fContexts.current.map(function (ctx, i) {\n    return ctx.update(arr[i]);\n  });\n  return outs;\n}\n\nfunction robustEquals(a, b) {\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  return a === b;\n}\n\nexport function changeCount(s) {\n  var count = useVar(0);\n  var previous = useVar(s);\n\n  if (!robustEquals(s, previous.current)) {\n    count.current++;\n  }\n\n  previous.current = s;\n  return count.current;\n}","import { useVar, useInitialize } from 'riv-runtime';\n\nvar snabbdom = require('snabbdom');\n\nvar patch = snabbdom.init([require('snabbdom/modules/class').default, require('snabbdom/modules/attributes').default, require('snabbdom/modules/style').default, require('snabbdom/modules/eventlisteners').default]);\nexport var h = require('snabbdom/h').default; // helper function for creating vnodes\n\nfunction cloneNode(vnode) {\n  return {\n    sel: vnode.sel,\n    data: vnode.data,\n    children: vnode.children && vnode.children.map(cloneNode),\n    text: vnode.text,\n    key: vnode.key,\n    elm: vnode.elm // I think this should be unset in our usage, since we only clone before passing to patch\n\n  };\n}\n/**\n * Note that element is only read upon init\n */\n\n\nexport function renderDOMIntoElement(vnode, containerElement) {\n  var savedContainerElement = useVar(containerElement);\n  var previousVnode = useVar(); // It's important that we clone the incoming vnode, because snabbdom will mutate it when we\n  // pass it to patch.\n\n  var clonedVnode = cloneNode(vnode);\n  useInitialize(function () {\n    return function () {\n      // cleanup\n      savedContainerElement.current.innerHTML = ''; // I think we want to do this\n    };\n  });\n\n  if (previousVnode.current) {\n    patch(previousVnode.current, clonedVnode);\n  } else {\n    // First patch\n    // Insert a dummy element because snabbdom replaces it (rather than inserting under)\n    var elem = document.createElement('div');\n    savedContainerElement.current.appendChild(elem);\n    patch(elem, clonedVnode);\n  }\n\n  previousVnode.current = clonedVnode;\n}\n/**\n * Note that selector is only read upon init\n */\n\nexport function renderDOMIntoSelector(vnode, containerSelector) {\n  var containerElement = useVar(function () {\n    return document.querySelector(containerSelector);\n  }); // cache\n\n  renderDOMIntoElement(vnode, containerElement.current);\n}\nexport function renderDOMAppendedToBody(vnode) {\n  var savedContainerElement = useVar();\n  useInitialize(function () {\n    var containerElement = document.createElement('div');\n    document.body.appendChild(containerElement);\n    savedContainerElement.current = containerElement;\n    return function () {\n      // cleanup\n      document.body.removeChild(containerElement);\n    };\n  });\n  renderDOMIntoElement(vnode, savedContainerElement.current);\n}","import { ExecutionContext } from 'riv-runtime';\nimport { CompiledDefinition } from \"./Compiler\";\n\nexport type StreamID = string;\nexport type FunctionID = string;\n\nexport interface ProgramNode {\n  type: 'Program';\n  mainDefinition: UserFunctionNode;\n}\nexport function isProgramNode(node: Node): node is ProgramNode {\n  return node.type === 'Program';\n}\n\nexport interface IdentifierNode {\n  type: 'Identifier';\n  name: string;\n}\nexport function isIdentifierNode(node: Node): node is IdentifierNode {\n  return node.type === 'Identifier';\n}\n\nexport interface UndefinedExpressionNode {\n  type: 'UndefinedExpression';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n}\nexport function isUndefinedExpressionNode(node: Node): node is UndefinedExpressionNode {\n  return node.type === 'UndefinedExpression';\n}\n\nexport interface IntegerLiteralNode {\n  type: 'IntegerLiteral';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n  value: number;\n}\nexport function isIntegerLiteralNode(node: Node): node is IntegerLiteralNode {\n  return node.type === 'IntegerLiteral';\n}\n\nexport interface ArrayLiteralNode {\n  type: 'ArrayLiteral';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n  items: ExpressionNode[];\n}\nexport function isArrayLiteralNode(node: Node): node is ArrayLiteralNode {\n  return node.type === 'ArrayLiteral';\n}\n\nexport interface StreamReferenceNode {\n  type: 'StreamReference';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n  targetStreamId: StreamID;\n}\nexport function isStreamReferenceNode(node: Node): node is StreamReferenceNode {\n  return node.type === 'StreamReference';\n}\n\nexport interface ApplicationNode {\n  type: 'Application';\n  streamId: StreamID, // stream of the function \"output\"\n  identifier: IdentifierNode | null;\n  functionId: FunctionID; // the function we are applying (calling), could be user-defined or external\n  arguments: Array<ExpressionNode>;\n  functionArguments: Array<UserFunctionNode>;\n}\nexport function isApplicationNode(node: Node): node is ApplicationNode {\n  return node.type === 'Application';\n}\n\nexport interface ParameterNode {\n  type: 'Parameter';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n}\nexport function isParameterNode(node: Node): node is ParameterNode {\n  return node.type === 'Parameter';\n}\n\nexport type ExpressionNode = UndefinedExpressionNode | IntegerLiteralNode | ArrayLiteralNode | StreamReferenceNode | ApplicationNode | ParameterNode;\nexport function isExpressionNode(node: Node): node is ExpressionNode {\n  return isUndefinedExpressionNode(node)\n    || isIntegerLiteralNode(node)\n    || isArrayLiteralNode(node)\n    || isStreamReferenceNode(node)\n    || isApplicationNode(node)\n    || isParameterNode(node);\n}\n\nexport interface FunctionSignature {\n  parameters: Array<string>; // just the names for now\n  functionParameters: Array<[string, FunctionSignature]>; // names and signatures\n}\n\nexport interface NativeFunctionNode {\n  type: 'NativeFunction';\n  functionId: FunctionID;\n  identifier: IdentifierNode | null;\n  signature: FunctionSignature;\n}\nexport function isNativeFunctionNode(node: Node): node is NativeFunctionNode {\n  return node.type === 'NativeFunction';\n}\n\nexport interface UserFunctionNode {\n  type: 'UserFunction';\n  functionId: FunctionID;\n  identifier: IdentifierNode | null;\n  signature: FunctionSignature;\n  parameters: Array<ParameterNode>;\n  functionParameterFunctionIds: Array<FunctionID>;\n  expressions: ExpressionNode[]; // the \"body\" of the function\n}\nexport function isUserFunctionNode(node: Node): node is UserFunctionNode {\n  return node.type === 'UserFunction';\n}\n\nexport type FunctionNode = NativeFunctionNode | UserFunctionNode;\nexport function isFunctionNode(node: Node): node is FunctionNode {\n  return isNativeFunctionNode(node) || isUserFunctionNode(node);\n}\n\nexport type Node = ProgramNode | IdentifierNode | ExpressionNode | FunctionNode;\nexport function isNode(node: any): node is Node {\n  return isProgramNode(node) || isIdentifierNode(node) || isExpressionNode(node) || isFunctionNode(node);\n}\n\nexport type Path = (string | number)[];\n\nexport interface State {\n  program: ProgramNode;\n  selectionPath: Path;\n  editingSelected: boolean;\n  nativeFunctions: Array<NativeFunctionNode>;\n  derivedLookups: {\n    streamIdToNode: Map<StreamID, ExpressionNode>;\n    // nameToNodes: Map<string, Node[]>;\n    functionIdToNode: Map<FunctionID, FunctionNode>;\n    // nameToFunctions: Map<string, Node[]>;\n  } | undefined;\n  liveMain: {\n    context: ExecutionContext;\n    compiledDefinition: CompiledDefinition | null;\n    updateCompiledDefinition: (newDefinition: CompiledDefinition) => void;\n  } | undefined;\n}\n","const gen32 = (): string => Math.random().toString(16).substring(2, 10);\n\nexport default (): string => gen32() + gen32();\n","import { State, StreamID, FunctionID, ExpressionNode, UserFunctionNode } from './State';\n\n/*\nSay we have the expression \"display(add(time(), 10))\". The call to display is an expression node, with streamId 'S1'. The call to add is an expression node with streamId 'S2'. The call to time is an expression node with streamId 'S3'. The literal 10 is a node with streamId 'S4'.\n\nconst compiledDefinition = {\n  parameterStreams: [],\n  literalStreamValues: [\n    ['S4', 10],\n  ],\n  applications: [\n    ['S3', 'time', [], []],\n    ['S2', 'add', ['S3', 'S4'], []],\n    ['S1', 'display', ['S2'], []],\n  ],\n  containedDefinitions: [],\n  yieldStream: null,\n};\n*/\n\nexport interface CompiledDefinition {\n  parameterStreams: Array<StreamID>;\n  // TODO: support function-parameters\n  literalStreamValues: Array<[StreamID, any]>;\n  applications: Array<[StreamID, FunctionID, Array<StreamID>, Array<FunctionID>]>;\n  containedDefinitions: Array<[FunctionID, CompiledDefinition]>;\n  yieldStream: StreamID | null;\n}\n\nexport class CompilationError extends Error {\n};\n\nfunction traverseFromExpression(expression: ExpressionNode, state: State, temporaryMarkedStreamIds: Set<StreamID>, permanentMarkedStreamIds: Set<StreamID>, compiledDefinition: CompiledDefinition) {\n  if (permanentMarkedStreamIds.has(expression.streamId)) {\n    return;\n  }\n\n  if (temporaryMarkedStreamIds.has(expression.streamId)) {\n    throw new CompilationError('graph cycle');\n  }\n\n\n  switch (expression.type) {\n    case 'Parameter':\n      // Nothing to be done\n      break;\n\n      case 'UndefinedExpression':\n      compiledDefinition.literalStreamValues.push([expression.streamId, undefined]);\n      break;\n\n    case 'IntegerLiteral':\n      compiledDefinition.literalStreamValues.push([expression.streamId, expression.value]);\n      break;\n\n    case 'ArrayLiteral':\n      temporaryMarkedStreamIds.add(expression.streamId);\n      for (const item of expression.items) {\n        traverseFromExpression(item, state, temporaryMarkedStreamIds, permanentMarkedStreamIds, compiledDefinition);\n      }\n      temporaryMarkedStreamIds.delete(expression.streamId);\n\n      // An array literal is handled as a function application, where the function is Array.of() which builds an array from its arguments.\n      compiledDefinition.applications.push([expression.streamId, 'Array_of', expression.items.map(item => item.streamId), []]);\n      break;\n\n    case 'StreamReference':\n      const targetExpressionNode = state.derivedLookups!.streamIdToNode.get(expression.targetStreamId);\n      if (!targetExpressionNode) {\n        throw Error();\n      }\n\n      temporaryMarkedStreamIds.add(expression.streamId);\n      traverseFromExpression(targetExpressionNode, state, temporaryMarkedStreamIds, permanentMarkedStreamIds, compiledDefinition);\n      temporaryMarkedStreamIds.delete(expression.streamId);\n\n      // For now, we do an inefficient copy rather than being smart\n      compiledDefinition.applications.push([expression.streamId, 'id', [expression.targetStreamId], []]);\n      break;\n\n    case 'Application':\n      const functionNode = state.derivedLookups!.functionIdToNode.get(expression.functionId);\n      if (!functionNode) {\n        throw Error();\n      }\n\n      temporaryMarkedStreamIds.add(expression.streamId);\n      for (const argument of expression.arguments) {\n        traverseFromExpression(argument, state, temporaryMarkedStreamIds, permanentMarkedStreamIds, compiledDefinition);\n      }\n      temporaryMarkedStreamIds.delete(expression.streamId);\n\n      for (const functionArgument of expression.functionArguments) {\n        // TODO: An application needs to traverse from its function-arguments out to any streams (in this exact scope)\n        // that it refers to (outer-scope references), because these are dependencies. So this would be an invalid cycle:\n        // x = map(v => x, [1,2,3])\n\n        compiledDefinition.containedDefinitions.push([functionArgument.functionId, compileUserDefinition(functionArgument, state)]);\n      }\n\n      compiledDefinition.applications.push([expression.streamId, functionNode.functionId, expression.arguments.map(item => item.streamId), expression.functionArguments.map(item => item.functionId)]);\n      break;\n\n    default:\n      throw new Error();\n  }\n\n  permanentMarkedStreamIds.add(expression.streamId);\n}\n\nexport function compileUserDefinition(definition: UserFunctionNode, state: State): CompiledDefinition {\n  // Using terminology from https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n  const temporaryMarkedStreamIds: Set<StreamID> = new Set();\n  const permanentMarkedStreamIds: Set<StreamID> = new Set();\n  const compiledDefinition: CompiledDefinition = {\n    parameterStreams: definition.parameters.map(param => param.streamId),\n    literalStreamValues: [],\n    applications: [],\n    containedDefinitions: [],\n    yieldStream: null,\n  };\n\n  for (const expression of definition.expressions) {\n    traverseFromExpression(expression, state, temporaryMarkedStreamIds, permanentMarkedStreamIds, compiledDefinition);\n    compiledDefinition.yieldStream = expression.streamId; // yield the last expression\n  }\n\n  return compiledDefinition;\n}\n","import { ExecutionContext, useVar, useInitialize, useRequestUpdate } from 'riv-runtime';\nimport { CompiledDefinition } from './Compiler';\nimport { StreamID, FunctionID } from './State';\n\nfunction arraysShallowEqual(a: Array<any>, b: Array<any>): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// TODO: We could just make this an alias for {[key: string]: V}, use plain funcs instead of methods\nexport class Environment<V> {\n  private obj: {[key: string]: V};\n\n  constructor(outer: Environment<V> | undefined = undefined) {\n    this.obj = Object.create(outer ? outer.obj : null);\n  }\n\n  get(name: string): V | undefined {\n    return this.obj[name];\n  }\n\n  set(name: string, value: V) {\n    this.obj[name] = value;\n  }\n\n  delete(name: string): void {\n    delete this.obj[name];\n  }\n}\n\n/**\n * Function environments may have names added or removed, but the value for a name must never change.\n */\nexport function createLiveFunction(initialDefinition: CompiledDefinition, outerStreamEnvironment: Environment<any>, outerFunctionEnvironment: Environment<Function>): [Function, (newDefinition: CompiledDefinition) => void] {\n  interface Activation {\n    streamEnvironment: Environment<any>;\n    functionEnvironment: Environment<Function>;\n    applicationContext: Map<string, ExecutionContext>;\n    updateContainedDefinition: Map<FunctionID, (newDefinition: CompiledDefinition) => void>;\n    requestUpdate: () => void;\n  }\n\n  const activations: Set<Activation> = new Set();\n  let compiledDefinition = initialDefinition;\n\n  function streamFunc() { // NOTE: this can't be an arrow function because we use \"arguments\"\n    /* eslint-disable react-hooks/rules-of-hooks */\n    const requestUpdate = useRequestUpdate();\n\n    const activation = useVar<Activation>(() => {\n      const streamEnvironment = new Environment(outerStreamEnvironment);\n      const functionEnvironment = new Environment(outerFunctionEnvironment);\n\n      for (const [sid, value] of compiledDefinition.literalStreamValues) {\n        streamEnvironment.set(sid, value);\n      }\n\n      const applicationContext: Map<StreamID, ExecutionContext> = new Map();\n      for (const [sid, fid, ] of compiledDefinition.applications) {\n        const func = functionEnvironment.get(fid);\n        if (!func) {\n          throw Error();\n        }\n        applicationContext.set(sid, new ExecutionContext(func, requestUpdate));\n      }\n\n      const updateContainedDefinition: Map<FunctionID, (newDefinition: CompiledDefinition) => void> = new Map();\n      for (const [fid, def] of compiledDefinition.containedDefinitions) {\n        const [sf, updateDef] = createLiveFunction(def, streamEnvironment, functionEnvironment);\n        functionEnvironment.set(fid, sf);\n        updateContainedDefinition.set(fid, updateDef);\n      }\n\n      return {\n        streamEnvironment,\n        functionEnvironment,\n        applicationContext,\n        updateContainedDefinition,\n        requestUpdate,\n      };\n    });\n\n    useInitialize(() => {\n      activations.add(activation.current);\n      return () => {\n        activation.current.applicationContext.forEach((ctx) => {\n          ctx.terminate();\n        });\n        activations.delete(activation.current);\n      };\n    });\n\n    const {streamEnvironment: streamEnv, functionEnvironment: funcEnv, applicationContext: appCtx} = activation.current;\n\n    if (arguments.length !== compiledDefinition.parameterStreams.length) {\n      throw new Error('wrong number of arguments to live function, got ' + arguments.length + ' expected ' + compiledDefinition.parameterStreams.length);\n    }\n    let idx = 0;\n    for (const sid of compiledDefinition.parameterStreams) {\n      streamEnv.set(sid, arguments[idx]);\n      idx++;\n    }\n\n    for (const [sid, , argIds, fargIds] of compiledDefinition.applications) {\n      const argVals = [...argIds.map(sid => streamEnv.get(sid)), ...fargIds.map(fid => funcEnv.get(fid))];\n      const context = appCtx.get(sid);\n      if (!context) { throw new Error(); }\n      let appVal;\n      try {\n        appVal = context.update(...argVals);\n      } catch (e) {\n        console.log('application error');\n      }\n      streamEnv.set(sid, appVal);\n    }\n\n    if (compiledDefinition.yieldStream) {\n      return streamEnv.get(compiledDefinition.yieldStream);\n    } else {\n      return undefined;\n    }\n  };\n\n  const updateCompiledDefinition = (newDefinition: CompiledDefinition): void => {\n    if (JSON.stringify(newDefinition) === JSON.stringify(compiledDefinition)) {\n      return;\n    }\n\n    //\n    // RECONCILE LITERALS\n    //\n    const oldLiteralMap: Map<string, any> = new Map();\n    const newLiteralMap: Map<string, any> = new Map();\n\n    for (const [sid, val] of compiledDefinition.literalStreamValues) {\n      oldLiteralMap.set(sid, val);\n    }\n    for (const [sid, val] of newDefinition.literalStreamValues) {\n      newLiteralMap.set(sid, val);\n    }\n\n    for (const [sid, ] of compiledDefinition.literalStreamValues) {\n      if (!newLiteralMap.has(sid)) {\n        activations.forEach(activation => {\n          activation.streamEnvironment.delete(sid);\n        });\n      }\n    }\n\n    for (const [sid, val] of newDefinition.literalStreamValues) {\n      if (!oldLiteralMap.has(sid) || (oldLiteralMap.get(sid) !== val)) {\n        activations.forEach(activation => {\n          activation.streamEnvironment.set(sid, val);\n        });\n      }\n    }\n\n    //\n    // RECONCILE APPLICATIONS\n    //\n    const oldAppMap: Map<string, [FunctionID, Array<string>]> = new Map();\n    const newAppMap: Map<string, [FunctionID, Array<string>]> = new Map();\n\n    for (const [sid, func, args] of compiledDefinition.applications) {\n      oldAppMap.set(sid, [func, args]);\n    }\n    for (const [sid, func, args] of newDefinition.applications) {\n      newAppMap.set(sid, [func, args]);\n    }\n\n    for (const [sid, , ] of compiledDefinition.applications) {\n      if (!newAppMap.has(sid)) {\n        activations.forEach(activation => {\n          activation.applicationContext.get(sid)!.terminate();\n        });\n      }\n    }\n\n    for (const [sid, funcId, args] of newDefinition.applications) {\n      let createNew = false;\n\n      const oldApp = oldAppMap.get(sid);\n      if (oldApp) {\n        const [oldFuncId, oldArgs] = oldApp;\n\n        if ((funcId !== oldFuncId) || !arraysShallowEqual(args, oldArgs)) {\n          activations.forEach(activation => {\n            activation.applicationContext.get(sid)!.terminate();\n          });\n\n          createNew = true;\n        }\n      } else {\n        createNew = true;\n      }\n\n      if (createNew) {\n        activations.forEach(activation => {\n          const func = activation.functionEnvironment.get(funcId);\n          if (!func) {\n            throw Error();\n          }\n          activation.applicationContext.set(sid, new ExecutionContext(func, activation.requestUpdate));\n        });\n      }\n    }\n\n    //\n    // RECONCILE CONTAINED DEFINITIONS\n    //\n    const oldDefMap: Map<FunctionID, CompiledDefinition> = new Map();\n    const newDefMap: Map<FunctionID, CompiledDefinition> = new Map();\n\n    for (const [fid, def] of compiledDefinition.containedDefinitions) {\n      oldDefMap.set(fid, def);\n    }\n    for (const [fid, def] of newDefinition.containedDefinitions) {\n      newDefMap.set(fid, def);\n    }\n\n    for (const [fid, ] of compiledDefinition.containedDefinitions) {\n      if (!newDefMap.has(fid)) {\n        activations.forEach(activation => {\n          activation.functionEnvironment.delete(fid);\n          activation.updateContainedDefinition.delete(fid);\n        });\n      }\n    }\n\n    for (const [fid, def] of newDefinition.containedDefinitions) {\n      if (!oldDefMap.has(fid)) {\n        activations.forEach(activation => {\n          const [sf, updateDef] = createLiveFunction(def, activation.streamEnvironment, activation.functionEnvironment);\n          activation.functionEnvironment.set(fid, sf);\n          activation.updateContainedDefinition.set(fid, updateDef);\n        });\n      } else {\n        activations.forEach(activation => {\n          activation.updateContainedDefinition.get(fid)!(def);\n        });\n      }\n    }\n\n    //\n    // FINISH UP\n    //\n    compiledDefinition = newDefinition;\n\n    activations.forEach(activation => {\n      activation.requestUpdate();\n    });\n  };\n\n  return [streamFunc, updateCompiledDefinition];\n}\n","import { State, Path, StreamID, FunctionID, Node, isNode, isProgramNode, ExpressionNode, isExpressionNode, ArrayLiteralNode, isArrayLiteralNode, FunctionSignature, FunctionNode, isApplicationNode, UserFunctionNode, isUserFunctionNode, ProgramNode } from './State';\nimport genuid from './uid';\nimport { compileUserDefinition, CompilationError, CompiledDefinition } from './Compiler';\nimport { createNullaryVoidRootExecutionContext, beginBatch, endBatch } from 'riv-runtime';\nimport { createLiveFunction, Environment } from './LiveFunction';\nconst { showString, animationTime, mouseDown, changeCount, streamMap, audioDriver, random, mouseClickEvts } = require('riv-demo-lib');\n\n// We don't make a discriminated union of specific actions, but maybe we could\ninterface Action {\n  type: string;\n  char?: string;\n  newNode?: Node;\n}\n\ninterface HandlerArgs {\n  node: Node,\n  subpath: Path,\n  editingSelected: boolean,\n  action: Action;\n}\ntype HandlerResult = (undefined | [Node, Path, boolean]);\ntype Handler = [string, string[], (args: HandlerArgs) => HandlerResult];\n\n\nconst SCHEMA_NODES = {\n  Program: {\n    fields: {\n      mainDefinition: {type: 'node'},\n    }\n  },\n\n  Identifier: {\n    fields: {\n      name: {type: 'value'},\n    }\n  },\n\n  UndefinedExpression: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n    }\n  },\n\n  IntegerLiteral: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      value: {type: 'value'},\n    }\n  },\n\n  ArrayLiteral: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      items: {type: 'nodes'},\n    }\n  },\n\n  StreamReference: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      targetStreamId: {type: 'uid'},\n    }\n  },\n\n  Application: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      functionId: {type: 'uid'},\n      arguments: {type: 'nodes'},\n      functionArguments: {type: 'nodes'},\n    }\n  },\n\n  Parameter: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n    }\n  },\n\n  NativeFunction: {\n    fields: {\n      functionId: {type: 'uid'},\n      identifier: {type: 'node'},\n      signature: {type: 'value'},\n      jsFunction: {type: 'value'},\n    }\n  },\n\n  UserFunction: {\n    fields: {\n      functionId: {type: 'uid'},\n      identifier: {type: 'node'},\n      signature: {type: 'value'},\n      parameters: {type: 'nodes'},\n      functionParameterFunctionIds: {type: 'value'},\n      expressions: {type: 'nodes'},\n    }\n  },\n};\n\n// TODO: If we want to include other classes in the lists, generate an expansion over the closure\nconst SCHEMA_CLASSES: {[nodeType: string]: string[]} = {\n  Expression: ['UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference', 'Application', 'Parameter'],\n  Any: ['Program', 'Identifier', 'UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference', 'Application', 'NativeFunction', 'UserFunction'],\n}\n\nexport function nodeFromPath(root: Node, path: Path): Node {\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n  }\n  return cur;\n}\n\nexport function nodeOnPath(node: Node, root: Node, path: Path): boolean {\n  if (node === root) {\n    return true;\n  }\n\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n    if (node === cur) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function nodeSplitPath(node: Node, root: Node, path: Path): [Path, Path] {\n  let cur: any = root;\n  let idx = 0;\n  for (const seg of path) {\n    if (node === cur) {\n      return [path.slice(0, idx), path.slice(idx)];\n    }\n    cur = cur[seg];\n    idx++;\n  }\n\n  if (node === cur) {\n    return [path.slice(0, idx), path.slice(idx)];\n  } else {\n    throw new Error('node was not in path');\n  }\n}\n\nexport function addExpressionLocalEnvironment(expr: ExpressionNode, namedStreams: Array<[string, ExpressionNode]>, namedFunctions: Array<[string, FunctionNode]>) {\n  if (expr.identifier) {\n    namedStreams.push([expr.identifier.name, expr]);\n  }\n\n  switch (expr.type) {\n    case 'Application':\n      for (const sarg of expr.arguments) {\n        addExpressionLocalEnvironment(sarg, namedStreams, namedFunctions);\n      }\n      for (const farg of expr.functionArguments) {\n        // NOTE: We don't recurse into the function-argument since we only want the local scope\n        if (farg.identifier) {\n          namedFunctions.push([farg.identifier.name, farg]);\n        }\n      }\n      break;\n\n    case 'ArrayLiteral':\n      for (const item of expr.items) {\n        addExpressionLocalEnvironment(item, namedStreams, namedFunctions);\n      }\n      break;\n\n    case 'StreamReference':\n    case 'IntegerLiteral':\n    case 'UndefinedExpression':\n      // nothing to do\n      break;\n\n    default:\n      throw new Error();\n  }\n}\n\nexport function addUserFunctionLocalEnvironment(func: UserFunctionNode, namedStreams: Array<[string, ExpressionNode]>, namedFunctions: Array<[string, FunctionNode]>) {\n  for (const param of func.parameters) {\n    if (param.identifier) {\n      namedStreams.push([param.identifier.name, param]);\n    }\n  }\n\n  for (const exp of func.expressions) {\n    addExpressionLocalEnvironment(exp, namedStreams, namedFunctions);\n  }\n}\n\nexport function addEnvironmentAlongPath(root: Node, path: Path, namedStreams: Array<[string, ExpressionNode]>, namedFunctions: Array<[string, FunctionNode]>) {\n  let cur: Node = root;\n  for (const seg of path) {\n    if (cur.type === 'UserFunction') {\n      addUserFunctionLocalEnvironment(cur, namedStreams, namedFunctions);\n    }\n    cur = (cur as any)[seg];\n  }\n}\n\nexport function environmentForSelectedNode(state: State) {\n  const namedStreams: Array<[string, ExpressionNode]> = [];\n  const namedFunctions: Array<[string, FunctionNode]> = [];\n\n  for (const extFunc of state.nativeFunctions) {\n    if (extFunc.identifier) {\n      namedFunctions.push([extFunc.identifier.name, extFunc]);\n    }\n  }\n\n  addEnvironmentAlongPath(state.program, state.selectionPath, namedStreams, namedFunctions);\n\n  return {\n    namedStreams,\n    namedFunctions,\n  }\n}\n\nconst equiv = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);\n\nfunction deleteDefinitionExpression(node: UserFunctionNode, removeIdx: number): [UserFunctionNode, Path, boolean] {\n  // TODO: Handle case where we delete all expressions\n  if (typeof(removeIdx) !== 'number') {\n    throw new Error();\n  }\n  const newNode = {\n    ...node,\n    expressions: [\n      ...node.expressions.slice(0, removeIdx),\n      ...node.expressions.slice(removeIdx+1),\n    ],\n  };\n\n  if (newNode.expressions.length) {\n    let newIdx = removeIdx-1;\n    newIdx = Math.max(newIdx, 0);\n    newIdx = Math.min(newIdx, node.expressions.length-1);\n    return [newNode, ['expressions', newIdx], false];\n  } else {\n    // We've deleted all expressions, so make a single empty one.\n    newNode.expressions.push({\n      type: 'UndefinedExpression',\n      streamId: genuid(),\n      identifier: null,\n    });\n    return [newNode, ['expressions', 0], true];\n  }\n}\n\nconst HANDLERS: Handler[] = [\n  ['UserFunction', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n\n    // NOTE: This assumes that selection is on/in one of the expressions\n    const newExpressionIdx = () => {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      let newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n      newIdx = Math.max(newIdx, 0);\n      newIdx = Math.min(newIdx, node.expressions.length-1);\n      return newIdx;\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      return [node, ['expressions', newExpressionIdx()], false];\n    }\n  }],\n\n  ['UserFunction', ['DELETE'], ({node, subpath}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      return deleteDefinitionExpression(node, removeIdx);\n    }\n  }],\n\n  ['UserFunction', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      return [node, ['expressions', 0], false];\n    }\n  }],\n\n  ['Expression', ['TOGGLE_EDIT'], ({node, subpath, editingSelected}) => {\n    if (editingSelected) {\n      return [node, subpath, false];\n    } else {\n      switch (node.type) {\n        case 'IntegerLiteral':\n        case 'UndefinedExpression':\n        case 'StreamReference':\n        case 'Application':\n          return [node, subpath, true];\n\n        case 'ArrayLiteral':\n          // Can't directly edit\n          break;\n\n        default:\n          throw new Error();\n      }\n    }\n  }],\n\n  ['Expression', ['END_EXPRESSION_IDENTIFIER_EDIT'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (!equiv(subpath, ['identifier'])) {\n      throw new Error();\n    }\n    if (!node.identifier) {\n      throw new Error();\n    }\n    const trimmedName = node.identifier.name.trim();\n    return [{\n      ...node,\n      identifier: trimmedName ? {\n        type: 'Identifier',\n        name: trimmedName,\n      } : null,\n    }, [], false];\n  }],\n\n  ['Expression', ['BEGIN_OVERWRITE_EDIT'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    return [{\n      type: 'UndefinedExpression',\n      streamId: node.streamId,\n      identifier: node.identifier,\n    }, subpath, true];\n  }],\n\n  ['Any', ['UPDATE_NODE'], ({subpath, action, editingSelected}) => {\n    if (!action.newNode) {\n      throw new Error();\n    }\n    console.log('UPDATE_NODE newNode', action.newNode);\n    if (subpath.length === 0) {\n      return [action.newNode, subpath, editingSelected];\n    }\n  }],\n\n  ['UserFunction', ['EDIT_AFTER'], ({node, subpath}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length >= 2) && (subpath[0] === 'expressions')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: UserFunctionNode = {\n        ...node,\n        expressions: [\n          ...node.expressions.slice(0, afterIdx+1),\n          {\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          },\n          ...node.expressions.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['expressions', afterIdx+1], true];\n    }\n  }],\n\n  /**\n   * NAME on an expression will move to editing identifer.\n   */\n  ['Expression', ['BEGIN_EXPRESSION_IDENTIFIER_EDIT'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (equiv(subpath, [])) {\n      return [{\n        ...node,\n        identifier: node.identifier ? node.identifier : {type: 'Identifier', name: ''},\n      }, ['identifier'], true];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know array is displayed vertically for now\n  ['ArrayLiteral', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath}) => {\n    if (subpath.length === 2) {\n      if ((subpath[0] !== 'items') || (typeof(subpath[1]) !== 'number')) {\n        throw Error();\n      }\n      return [node, [], false];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_RIGHT to act as ZOOM_IN here because we know it will be in a vertical-list container\n  ['ArrayLiteral', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      // We do a special thing here: If the array is empty, we create a single undefined item.\n      // This gives us a way to add a new element to an empty array.\n      if (node.items.length === 0) {\n        return [{\n          ...node,\n          items: [\n            {\n              type: 'UndefinedExpression',\n              streamId: genuid(),\n              identifier: null,\n            }\n          ],\n        }, ['items', 0], true];\n      } else {\n        return [node, ['items', 0], false];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx < 0) || (newIdx >= node.items.length)) {\n        return [node, [], false];\n      } else {\n        return [node, ['items', newIdx], false];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['EDIT_AFTER'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: ArrayLiteralNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, afterIdx+1),\n          {\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          },\n          ...node.items.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['items', afterIdx+1], true];\n    }\n  }],\n\n  ['ArrayLiteral', ['DELETE'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if (node.items.length === 0) {\n        throw new Error();\n      }\n\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, removeIdx),\n          ...node.items.slice(removeIdx+1),\n        ],\n      };\n\n      if (newNode.items.length > 0) {\n        let newIdx = removeIdx-1;\n        newIdx = Math.max(newIdx, 0);\n        newIdx = Math.min(newIdx, node.items.length-1);\n        return [newNode, ['items', newIdx], false];\n      } else {\n        return [newNode, [], false];\n      }\n    }\n  }],\n\n  ['Expression', ['CREATE_ARRAY'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n\n    if (subpath.length === 0) {\n      return [{\n        type: 'ArrayLiteral',\n        streamId: node.streamId,\n        identifier: node.identifier,\n        items: [\n          {\n            type: 'UndefinedExpression',\n            identifier: null,\n            streamId: genuid(),\n          }\n        ],\n      }, ['items', 0], true];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know arguments are displayed vertically for now\n  ['Application', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if ((subpath[0] === 'arguments') && (typeof(subpath[1]) === 'number')) {\n        return [node, [], false];\n      } else if ((subpath[0] === 'functionArguments') && (typeof(subpath[1]) === 'number')) {\n        return [node, [], false];\n      } else {\n        throw new Error();\n      }\n    } else if ((subpath.length >= 3) && (subpath[0] === 'functionArguments') && (typeof(subpath[1]) === 'number')) {\n      // We handle this here (slightly unusual) so that user can't zoom out to main function definition\n      return [node, subpath.slice(0, 2), false];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_RIGHT to act as ZOOM_IN here because we know arguments are displayed vertically for now\n  ['Application', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      if (node.arguments.length > 0) {\n        return [node, ['arguments', 0], false];\n      } else if (node.functionArguments.length > 0) {\n        return [node, ['functionArguments', 0], false];\n      }\n    }\n  }],\n\n  ['Application', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'arguments')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx >= node.arguments.length) && node.functionArguments.length) {\n        return [node, ['functionArguments', 0], false];\n      } else if ((newIdx < 0) || (newIdx >= node.arguments.length)) {\n        return [node, [], false];\n      } else {\n        return [node, ['arguments', newIdx], false];\n      }\n    } else if ((subpath.length === 2) && (subpath[0] === 'functionArguments')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx < 0) && node.arguments.length) {\n        return [node, ['arguments', node.arguments.length-1], false];\n      } else if ((newIdx < 0) || (newIdx >= node.arguments.length)) {\n        return [node, [], false];\n      } else {\n        return [node, ['functionArguments', newIdx], false];\n      }\n    }\n  }],\n\n  ['Application', ['DELETE'], ({node, subpath, action}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'arguments')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n\n      const newArguments = node.arguments.slice();\n      newArguments[idx] = {\n        type: 'UndefinedExpression',\n        streamId: node.arguments[idx].streamId,\n        identifier: node.arguments[idx].identifier,\n      };\n\n      return [{\n        ...node,\n        arguments: newArguments,\n      }, ['arguments', idx], false];\n    }\n  }],\n];\n\n/**\n * Returns null or [newNode, newSelectionPath, newTextEdit]\n */\nfunction recursiveReducer(state: State, node: Node, action: Action): (null | [Node, Path, boolean]) {\n  // If this node is not on the selection path, we can short circuit\n  if (!nodeOnPath(node, state.program, state.selectionPath)) {\n    return null;\n  }\n\n  // Build new node, recursing into any child nodes\n  // If nothing has changed, we try to return the original object to allow callers to memoize\n  const nodeInfo = SCHEMA_NODES[node.type];\n  if (!nodeInfo) {\n    throw new Error();\n  }\n  const newNode: any = {\n    type: node.type,\n  };\n  let newSelPath = null;\n  let newEditingSelected = false;\n  let handled = false;\n  const indexableNode = node as {[prop: string]: any}; // to avoid type errors\n  for (const [fieldName, fieldInfo] of Object.entries(nodeInfo.fields)) {\n    switch (fieldInfo.type) {\n      case 'node': {\n        const childNode = indexableNode[fieldName];\n        const recResult = recursiveReducer(state, childNode, action);\n        if (recResult) {\n          if (handled) {\n            throw new Error('already handled');\n          }\n          const [n, sp, es] = recResult;\n          newNode[fieldName] = n;\n          newSelPath = sp;\n          newEditingSelected = es;\n          handled = true;\n        } else {\n          newNode[fieldName] = childNode;\n        }\n        break;\n      }\n\n      case 'nodes': {\n        const newArr = [];\n        const childNodes = indexableNode[fieldName];\n        for (const arrn of childNodes) {\n          const recResult = recursiveReducer(state, arrn, action);\n          if (recResult) {\n            if (handled) {\n              throw new Error('already handled');\n            }\n            const [n, sp, es] = recResult;\n            newArr.push(n);\n            newSelPath = sp;\n            newEditingSelected = es;\n            handled = true;\n          } else {\n            newArr.push(arrn);\n          }\n        }\n        newNode[fieldName] = newArr;\n        break;\n      }\n\n      case 'value':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      case 'uid':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      default:\n        throw new Error();\n    }\n  }\n\n  // If the action has been handled, we can return now\n  if (handled) {\n    if (!isNode(newNode)) {\n      throw new Error();\n    }\n    if (!newSelPath) {\n      throw new Error();\n    }\n    return [newNode, newSelPath, newEditingSelected];\n  }\n\n  // Try any matching handlers\n  for (const [nt, acts, hfunc] of HANDLERS) {\n    const matchingTypes = SCHEMA_CLASSES[nt] ? SCHEMA_CLASSES[nt] : [nt];\n    if (matchingTypes.includes(node.type) && acts.includes(action.type)) {\n      const [pathBefore, pathAfter] = nodeSplitPath(node, state.program, state.selectionPath);\n      const handlerResult = hfunc({\n        node,\n        subpath: pathAfter,\n        editingSelected: state.editingSelected,\n        action,\n      });\n      if (handlerResult) {\n        // console.log('handlerResult', handlerResult);\n        const [handlerNewNode, handlerNewSubpath, handlerNewEditingSelected] = handlerResult;\n        return [handlerNewNode, pathBefore.concat(handlerNewSubpath), handlerNewEditingSelected];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction recursiveBuildIdMaps(node: Node, streamIdToNode: Map<StreamID, Node>, functionIdToNode: Map<FunctionID, FunctionNode>): void {\n  if (isExpressionNode(node)) {\n    if (streamIdToNode.has(node.streamId)) {\n      throw new Error('stream ids must be unique');\n    }\n    streamIdToNode.set(node.streamId, node);\n  }\n\n  switch (node.type) {\n    case 'Program':\n      recursiveBuildIdMaps(node.mainDefinition, streamIdToNode, functionIdToNode);\n      break;\n\n    case 'UserFunction':\n      if (functionIdToNode.has(node.functionId)) {\n        throw new Error('function ids must be unique');\n      }\n      functionIdToNode.set(node.functionId, node);\n\n      for (const param of node.parameters) {\n        if (streamIdToNode.has(param.streamId)) {\n          throw new Error('stream ids must be unique');\n        }\n        streamIdToNode.set(param.streamId, param);\n      }\n\n      for (const expression of node.expressions) {\n        recursiveBuildIdMaps(expression, streamIdToNode, functionIdToNode);\n      }\n      break;\n\n    case 'Application':\n      for (const arg of node.arguments) {\n        recursiveBuildIdMaps(arg, streamIdToNode, functionIdToNode);\n      }\n      for (const farg of node.functionArguments) {\n        recursiveBuildIdMaps(farg, streamIdToNode, functionIdToNode);\n      }\n      break;\n\n    case 'ArrayLiteral':\n      for (const item of node.items) {\n        recursiveBuildIdMaps(item, streamIdToNode, functionIdToNode);\n      }\n      break;\n\n    case 'IntegerLiteral':\n    case 'UndefinedExpression':\n    case 'StreamReference':\n      // NOTE: nothing to recurse into\n      break;\n\n    default:\n      throw new Error();\n  }\n}\n\nfunction addStateLookups(state: State): State {\n  const streamIdToNode: Map<StreamID, ExpressionNode> = new Map();\n  const functionIdToNode: Map<FunctionID, FunctionNode> = new Map();\n\n  for (const extFunc of state.nativeFunctions) {\n    functionIdToNode.set(extFunc.functionId, extFunc);\n  }\n\n  recursiveBuildIdMaps(state.program, streamIdToNode, functionIdToNode);\n\n  return {\n    ...state,\n    derivedLookups: {\n      streamIdToNode,\n      functionIdToNode,\n    },\n  }\n}\n\nfunction recursiveUndefineDanglingStreamRefs(node: Node, streamIdToNode: Map<StreamID, Node>): Node {\n  switch (node.type) {\n    case 'Program':\n      return {\n        ...node,\n        mainDefinition: recursiveUndefineDanglingStreamRefs(node.mainDefinition, streamIdToNode) as UserFunctionNode,\n      };\n\n    case 'UserFunction':\n      return {\n        ...node,\n        expressions: node.expressions.map(expr => recursiveUndefineDanglingStreamRefs(expr, streamIdToNode)) as Array<ExpressionNode>,\n      };\n\n    case 'Application':\n      return {\n        ...node,\n        arguments: node.arguments.map(arg => recursiveUndefineDanglingStreamRefs(arg, streamIdToNode)) as Array<ExpressionNode>,\n        functionArguments: node.functionArguments.map(farg => recursiveUndefineDanglingStreamRefs(farg, streamIdToNode)) as Array<UserFunctionNode>,\n      };\n\n    case 'ArrayLiteral':\n      return {\n        ...node,\n        items: node.items.map(item => recursiveUndefineDanglingStreamRefs(item, streamIdToNode)) as Array<ExpressionNode>,\n      };\n\n    case 'IntegerLiteral':\n    case 'UndefinedExpression':\n      // NOTE: nothing to do\n      return node;\n\n    case 'StreamReference':\n      // This is the important case\n      return streamIdToNode.has(node.targetStreamId) ? node : {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: node.identifier,\n      };\n\n    default:\n      throw new Error();\n  }\n}\n\nfunction undefineDanglingStreamRefs(state: State): State {\n  return {\n    ...state,\n    program: recursiveUndefineDanglingStreamRefs(state.program, state.derivedLookups!.streamIdToNode) as ProgramNode,\n  }\n}\n\nfunction addStateCompiled(oldState: State | undefined, newState: State): State {\n  // We initialize with an \"empty\" definition, which we fall back on if compilation fails\n  let newCompiledDefinition: CompiledDefinition = {\n    parameterStreams: [],\n    literalStreamValues: [],\n    applications: [],\n    containedDefinitions: [],\n    yieldStream: null,\n  };\n\n  try {\n    newCompiledDefinition = compileUserDefinition(newState.program.mainDefinition, newState);\n    // console.log('compiled to', newCompiledDefinition);\n  } catch (e) {\n    if (e instanceof CompilationError) {\n      console.log('COMPILATION ERROR', e.message);\n    } else {\n      throw e;\n    }\n  }\n\n  let newLiveMain;\n\n  if (oldState) {\n    const { context, updateCompiledDefinition } = oldState.liveMain!;\n\n    console.log('updating compiled definition to', newCompiledDefinition);\n    beginBatch(); // batch thing is not necessary yet, but will be in the future\n    updateCompiledDefinition(newCompiledDefinition);\n    endBatch();\n\n    newLiveMain = {\n      context,\n      updateCompiledDefinition,\n      compiledDefinition: newCompiledDefinition,\n    };\n  } else {\n    // There is no old state, so we need to create the long-lived stuff\n    console.log('initializing compiled definition to', newCompiledDefinition);\n    const [liveStreamFunc, updateCompiledDefinition] = createLiveFunction(newCompiledDefinition, new Environment(), nativeFunctionEnvironment);\n    const context = createNullaryVoidRootExecutionContext(liveStreamFunc);\n\n    context.update(); // first update that generally kicks off further async updates\n\n    newLiveMain = {\n      context,\n      updateCompiledDefinition,\n      compiledDefinition: newCompiledDefinition,\n    };\n  }\n\n  return {\n    ...newState,\n    liveMain: newLiveMain,\n  };\n}\n\nfunction addDerivedState(oldState: State | undefined, newState: State): State {\n  return addStateCompiled(oldState, undefineDanglingStreamRefs(addStateLookups(newState)));\n}\n\nexport function reducer(state: State, action: Action): State {\n  console.log('action', action.type);\n\n  const recResult = recursiveReducer(state, state.program, action);\n  if (recResult) {\n    console.log('handled');\n    const [newProgram, newSelectionPath, newEditingSelected] = recResult;\n    // console.log('new selectionPath is', newSelectionPath, 'newEditingSelected is', newEditingSelected);\n    // console.log('new prog', newProgram);\n\n    if (!isProgramNode(newProgram)) {\n      throw new Error();\n    }\n\n    return addDerivedState(state, {\n      program: newProgram,\n      selectionPath: newSelectionPath,\n      editingSelected: newEditingSelected,\n      nativeFunctions: state.nativeFunctions,\n      derivedLookups: undefined,\n      liveMain: undefined,\n    });\n  } else {\n    console.log('not handled');\n    return state;\n  }\n}\n\nconst nativeFunctions: Array<[string, Array<string>, Array<[string, FunctionSignature]>, Function]> = [\n  ['add', ['_a', '_b'], [], (a: number, b: number) => a + b],\n  ['multiply', ['_a', '_b'], [], (a: number, b: number) => a * b],\n  ['show value', ['_v'], [], showString],\n  ['animation time', [], [], animationTime],\n  ['is mouse down', [], [], mouseDown],\n  ['change count', ['_stream'], [], changeCount],\n  ['map', ['_array'], [['_func', {parameters: ['value'], functionParameters: []}]], (arr: Array<any>, f: (v: any) => any) => streamMap(f, arr)],\n  ['if', ['_pred', 'then', 'else'], [], (_pred: any, _then: any, _else: any) => (_pred ? _then : _else)],\n  ['audio driver', [], [['_func', {parameters: ['audio time', 'next frame', 'sample rate'], functionParameters: []}]], audioDriver],\n  ['cosine', ['_v'], [], Math.cos],\n  ['random', ['repick'], [], random],\n  ['mouse click', [], [], mouseClickEvts],\n];\n\nconst nativeFunctionEnvironment: Environment<Function> = new Environment();\nnativeFunctionEnvironment.set('id', (x: any) => x);\nnativeFunctionEnvironment.set('Array_of', Array.of);\nnativeFunctions.forEach(([name, , , jsFunc]) => {\n  nativeFunctionEnvironment.set(name, jsFunc);\n});\n\nconst mdId = genuid();\nexport const initialState: State = addDerivedState(undefined, {\n  program: {\n    type: 'Program',\n    mainDefinition: {\n      type: 'UserFunction',\n      functionId: genuid(),\n      identifier: null,\n      signature: {\n        parameters: [],\n        functionParameters: [],\n      },\n      parameters: [],\n      functionParameterFunctionIds: [],\n      expressions: [\n        {\n          type: 'Application',\n          streamId: mdId,\n          identifier: {\n            type: 'Identifier',\n            name: 'md',\n          },\n          functionId: 'is mouse down',\n          arguments: [],\n          functionArguments: [],\n        },\n        {\n          type: 'Application',\n          streamId: genuid(),\n          identifier: null,\n          functionId: 'show value',\n          arguments: [\n            {\n              type: 'Application',\n              streamId: genuid(),\n              identifier: null,\n              functionId: 'if',\n              arguments: [\n                {\n                  type: 'StreamReference',\n                  streamId: genuid(),\n                  identifier: null,\n                  targetStreamId: mdId,\n                },\n                {\n                  type: 'IntegerLiteral',\n                  streamId: genuid(),\n                  identifier: null,\n                  value: 10,\n                },\n                {\n                  type: 'IntegerLiteral',\n                  streamId: genuid(),\n                  identifier: null,\n                  value: 20,\n                },\n              ],\n              functionArguments: [],\n            },\n          ],\n          functionArguments: [],\n        },\n      ],\n    },\n  },\n  selectionPath: ['mainDefinition', 'expressions', 0],\n  editingSelected: false,\n  nativeFunctions: nativeFunctions.map(([name, paramNames, funcParams, ]) => ({\n    type: 'NativeFunction',\n    functionId: name,\n    identifier: {\n      type: 'Identifier',\n      name: name,\n    },\n    signature: {\n      parameters: paramNames,\n      functionParameters: funcParams,\n    },\n  })),\n  derivedLookups: undefined,\n  liveMain: undefined,\n});\n","// slightly adapted from https://github.com/forrestthewoods/lib_fts/blob/master/code/fts_fuzzy_match.js\r\n\r\n// LICENSE\r\n//\r\n//   This software is dual-licensed to the public domain and under the following\r\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\r\n//   publish, and distribute this file as you see fit.\r\n//\r\n// VERSION\r\n//   0.1.0  (2016-03-28)  Initial release\r\n//\r\n// AUTHOR\r\n//   Forrest Smith\r\n//\r\n// CONTRIBUTORS\r\n//   Jrgen Tjern - async helper\r\n\r\n\r\n// Returns true if each character in pattern is found sequentially within str\r\nexport function fuzzy_match_simple(pattern, str) {\r\n\r\n    var patternIdx = 0;\r\n    var strIdx = 0;\r\n    var patternLength = pattern.length;\r\n    var strLength = str.length;\r\n\r\n    while (patternIdx !== patternLength && strIdx !== strLength) {\r\n        var patternChar = pattern.charAt(patternIdx).toLowerCase();\r\n        var strChar = str.charAt(strIdx).toLowerCase();\r\n        if (patternChar === strChar)\r\n            ++patternIdx;\r\n        ++strIdx;\r\n    }\r\n\r\n    return patternLength !== 0 && strLength !== 0 && patternIdx === patternLength ? true : false;\r\n}\r\n\r\n// Returns [bool, score, formattedStr]\r\n// bool: true if each character in pattern is found sequentially within str\r\n// score: integer; higher is better match. Value has no intrinsic meaning. Range varies with pattern.\r\n//        Can only compare scores with same search pattern.\r\n// formattedStr: input str with matched characters marked in <b> tags. Delete if unwanted.\r\nexport function fuzzy_match(pattern, str) {\r\n\r\n    // Score consts\r\n    var adjacency_bonus = 5;                // bonus for adjacent matches\r\n    var separator_bonus = 10;               // bonus if match occurs after a separator\r\n    var camel_bonus = 10;                   // bonus if match is uppercase and prev is lower\r\n    var leading_letter_penalty = -3;        // penalty applied for every letter in str before the first match\r\n    var max_leading_letter_penalty = -9;    // maximum penalty for leading letters\r\n    var unmatched_letter_penalty = -1;      // penalty for every letter that doesn't matter\r\n\r\n    // Loop variables\r\n    var score = 0;\r\n    var patternIdx = 0;\r\n    var patternLength = pattern.length;\r\n    var strIdx = 0;\r\n    var strLength = str.length;\r\n    var prevMatched = false;\r\n    var prevLower = false;\r\n    var prevSeparator = true;       // true so if first letter match gets separator bonus\r\n\r\n    // Use \"best\" matched letter if multiple string letters match the pattern\r\n    var bestLetter = null;\r\n    var bestLower = null;\r\n    var bestLetterIdx = null;\r\n    var bestLetterScore = 0;\r\n\r\n    var matchedIndices = [];\r\n\r\n    // Loop over strings\r\n    while (strIdx !== strLength) {\r\n        var patternChar = patternIdx !== patternLength ? pattern.charAt(patternIdx) : null;\r\n        var strChar = str.charAt(strIdx);\r\n\r\n        var patternLower = patternChar !== null ? patternChar.toLowerCase() : null;\r\n        var strLower = strChar.toLowerCase();\r\n        var strUpper = strChar.toUpperCase();\r\n\r\n        var nextMatch = patternChar && patternLower === strLower;\r\n        var rematch = bestLetter && bestLower === strLower;\r\n\r\n        var advanced = nextMatch && bestLetter;\r\n        var patternRepeat = bestLetter && patternChar && bestLower === patternLower;\r\n        if (advanced || patternRepeat) {\r\n            score += bestLetterScore;\r\n            matchedIndices.push(bestLetterIdx);\r\n            bestLetter = null;\r\n            bestLower = null;\r\n            bestLetterIdx = null;\r\n            bestLetterScore = 0;\r\n        }\r\n\r\n        if (nextMatch || rematch) {\r\n            var newScore = 0;\r\n\r\n            // Apply penalty for each letter before the first pattern match\r\n            // Note: std::max because penalties are negative values. So max is smallest penalty.\r\n            if (patternIdx === 0) {\r\n                var penalty = Math.max(strIdx * leading_letter_penalty, max_leading_letter_penalty);\r\n                score += penalty;\r\n            }\r\n\r\n            // Apply bonus for consecutive bonuses\r\n            if (prevMatched)\r\n                newScore += adjacency_bonus;\r\n\r\n            // Apply bonus for matches after a separator\r\n            if (prevSeparator)\r\n                newScore += separator_bonus;\r\n\r\n            // Apply bonus across camel case boundaries. Includes \"clever\" isLetter check.\r\n            if (prevLower && strChar === strUpper && strLower !== strUpper)\r\n                newScore += camel_bonus;\r\n\r\n            // Update patter index IFF the next pattern letter was matched\r\n            if (nextMatch)\r\n                ++patternIdx;\r\n\r\n            // Update best letter in str which may be for a \"next\" letter or a \"rematch\"\r\n            if (newScore >= bestLetterScore) {\r\n\r\n                // Apply penalty for now skipped letter\r\n                if (bestLetter !== null)\r\n                    score += unmatched_letter_penalty;\r\n\r\n                bestLetter = strChar;\r\n                bestLower = bestLetter.toLowerCase();\r\n                bestLetterIdx = strIdx;\r\n                bestLetterScore = newScore;\r\n            }\r\n\r\n            prevMatched = true;\r\n        }\r\n        else {\r\n            // Append unmatch characters\r\n            // formattedStr += strChar; // NOTE: This line appears to be useless, and generates warning -Russ\r\n\r\n            score += unmatched_letter_penalty;\r\n            prevMatched = false;\r\n        }\r\n\r\n        // Includes \"clever\" isLetter check.\r\n        prevLower = strChar === strLower && strLower !== strUpper;\r\n        prevSeparator = strChar === '_' || strChar === ' ';\r\n\r\n        ++strIdx;\r\n    }\r\n\r\n    // Apply score for last match\r\n    if (bestLetter) {\r\n        score += bestLetterScore;\r\n        matchedIndices.push(bestLetterIdx);\r\n    }\r\n\r\n    // Finish out formatted string after last pattern matched\r\n    // Build formated string based on matched letters\r\n    var formattedStr = \"\";\r\n    var lastIdx = 0;\r\n    for (var i = 0; i < matchedIndices.length; ++i) {\r\n        var idx = matchedIndices[i];\r\n        formattedStr += str.substr(lastIdx, idx - lastIdx) + \"<b>\" + str.charAt(idx) + \"</b>\";\r\n        lastIdx = idx + 1;\r\n    }\r\n    formattedStr += str.substr(lastIdx, str.length - lastIdx);\r\n\r\n    var matched = patternIdx === patternLength;\r\n    return [matched, score, formattedStr];\r\n}\r\n\r\n\r\n// Strictly optional utility to help make using fts_fuzzy_match easier for large data sets\r\n// Uses setTimeout to process matches before a maximum amount of time before sleeping\r\n//\r\n// To use:\r\n//      var asyncMatcher = new fts_fuzzy_match(fuzzy_match, \"fts\", \"ForrestTheWoods\",\r\n//                                              function(results) { console.log(results); });\r\n//      asyncMatcher.start();\r\n//\r\nexport function fts_fuzzy_match_async(matchFn, pattern, dataSet, onComplete) {\r\n    var ITEMS_PER_CHECK = 1000;         // performance.now can be very slow depending on platform\r\n\r\n    var max_ms_per_frame = 1000.0/30.0; // 30FPS\r\n    var dataIndex = 0;\r\n    var results = [];\r\n    var resumeTimeout = null;\r\n\r\n    // Perform matches for at most max_ms\r\n    function step() {\r\n        clearTimeout(resumeTimeout);\r\n        resumeTimeout = null;\r\n\r\n        var stopTime = performance.now() + max_ms_per_frame;\r\n\r\n        for (; dataIndex < dataSet.length; ++dataIndex) {\r\n            if ((dataIndex % ITEMS_PER_CHECK) === 0) {\r\n                if (performance.now() > stopTime) {\r\n                    resumeTimeout = setTimeout(step, 1);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            var str = dataSet[dataIndex];\r\n            var result = matchFn(pattern, str);\r\n\r\n            // A little gross because fuzzy_match_simple and fuzzy_match return different things\r\n            if (matchFn === fuzzy_match_simple && result === true)\r\n                results.push(str);\r\n            else if (matchFn === fuzzy_match && result[0] === true)\r\n                results.push(result);\r\n        }\r\n\r\n        onComplete(results);\r\n        return null;\r\n    };\r\n\r\n    // Abort current process\r\n    this.cancel = function() {\r\n        if (resumeTimeout !== null)\r\n            clearTimeout(resumeTimeout);\r\n    };\r\n\r\n    // Must be called to start matching.\r\n    // I tried to make asyncMatcher auto-start via \"var resumeTimeout = step();\"\r\n    // However setTimout behaving in an unexpected fashion as onComplete insisted on triggering twice.\r\n    this.start = function() {\r\n        step();\r\n    }\r\n\r\n    // Process full list. Blocks script execution until complete\r\n    this.flush = function() {\r\n        max_ms_per_frame = Infinity;\r\n        step();\r\n    }\r\n};\r\n","import React, { useState, useEffect, useRef } from 'react';\nimport './ExpressionChooser.css';\nimport { fuzzy_match } from './vendor/fts_fuzzy_match';\nimport genuid from './uid';\nimport { environmentForSelectedNode } from './EditReducer';\n\nfunction fuzzySearch(query, items) {\n  const results = [];\n\n  for (const [name, data] of items) {\n    const [hit, score, formattedStr] = fuzzy_match(query, name);\n    if (hit) {\n      results.push({\n        score,\n        formattedStr,\n        name,\n        data,\n      });\n    }\n  }\n  if (query !== '') { // TODO: this is a hack, is query is empty, scoring is dumb\n    results.sort((a, b) => (b.score - a.score));\n  }\n  return results;\n}\n\nconst FLOAT_REGEX = /^[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?$/;\n\nfunction generateChoices(text, mainState) {\n  const choices = [];\n\n  // If there is no text, put this first as a sort of default\n  if (text === '') {\n    choices.push({\n      type: 'undefined',\n    });\n  }\n\n  const { namedStreams, namedFunctions } = environmentForSelectedNode(mainState);\n\n  const streamSearchResults = fuzzySearch(text, namedStreams);\n  for (const result of streamSearchResults) {\n    choices.push({\n      type: 'streamref',\n      node: result.data,\n    });\n  }\n\n  const functionSearchResults = fuzzySearch(text, namedFunctions);\n  for (const result of functionSearchResults) {\n    choices.push({\n      type: 'function',\n      node: result.data,\n    });\n  }\n\n  if (FLOAT_REGEX.test(text)) {\n    choices.push({\n      type: 'number',\n      value: Number(text),\n    });\n  }\n\n  if (choices.length === 0) {\n    choices.push({\n      type: 'undefined',\n    });\n  }\n\n  return choices;\n}\n\nfunction Choice({ choice }) {\n  switch (choice.type) {\n    case 'undefined':\n      return <em>undefined</em>\n\n    case 'number':\n      return <span>{choice.value}</span>\n\n    case 'streamref':\n      return <span><em>S</em> {choice.node.identifier.name} <small>(id {choice.node.streamId})</small></span>\n\n    case 'function':\n      return <span><em>F</em> {choice.node.identifier.name}({[].concat([\n        choice.node.signature.parameters.map(n => (n.startsWith('_') ? '\\u25A1' : n)), // parameters\n        choice.node.signature.functionParameters.map(([n, ]) => 'F ' + ((n.startsWith('_') ? '\\u25A1' : n))), // function parameters\n      ]).join(', ')})</span>\n\n    default:\n      throw new Error();\n  }\n}\n\nexport default function ExpressionChooser({ node, mainState, dispatch }) {\n  const selectedListElem = useRef();\n  useEffect(() => {\n    if (selectedListElem.current) {\n      selectedListElem.current.scrollIntoView({block: 'nearest', inline: 'nearest'});\n    }\n  });\n\n  const [text, setText] = useState(() => {\n    // Initialize text based on existing node\n    switch (node.type) {\n      case 'UndefinedExpression':\n        return '';\n\n      case 'IntegerLiteral':\n        return node.value.toString();\n\n      case 'StreamReference': {\n        const targetExpressionNode = mainState.derivedLookups.streamIdToNode.get(node.targetStreamId);\n        return targetExpressionNode.identifier ? targetExpressionNode.identifier.name : '';\n      }\n\n      case 'Application': {\n        const functionNode = mainState.derivedLookups.functionIdToNode.get(node.functionId);\n        return functionNode.identifier ? functionNode.identifier.name : '';\n      }\n\n      default:\n        throw new Error();\n    }\n  });\n\n  // Update the expression node to reflect the current choice\n  const realizeChoice = (state) => {\n    const choice = state.choices[state.index];\n\n    let newNode;\n    switch (choice.type) {\n      case 'undefined':\n        newNode = {\n          type: 'UndefinedExpression',\n        }\n        break;\n\n      case 'number':\n        newNode = {\n          type: 'IntegerLiteral',\n          value: choice.value,\n        };\n        break;\n\n      case 'streamref':\n        newNode = {\n          type: 'StreamReference',\n          targetStreamId: choice.node.streamId,\n        };\n        break;\n\n      case 'function':\n        newNode = {\n          type: 'Application',\n          functionId: choice.node.functionId,\n          arguments: choice.node.signature.parameters.map(paramName => ({\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          })),\n          functionArguments: choice.node.signature.functionParameters.map(([, signature]) => ({\n            type: 'UserFunction',\n            functionId: genuid(),\n            identifier: null,\n            signature, // TODO: do we need to defensively copy this?\n            parameters: signature.parameters.map(pn => ({\n              type: 'Parameter',\n              streamId: genuid(),\n              identifier: {\n                type: 'Identifier',\n                name: pn,\n              },\n            })),\n            functionParameterFunctionIds: signature.functionParameters.map(([pn, sig]) => genuid()),\n            expressions: [\n              {\n                type: 'UndefinedExpression',\n                streamId: genuid(),\n                identifier: null,\n              },\n            ],\n          })),\n        };\n        break;\n\n      default:\n        throw new Error();\n    }\n\n    newNode.streamId = node.streamId;\n    newNode.identifier = node.identifier;\n\n    dispatch({type: 'UPDATE_NODE', newNode});\n  };\n\n  const recomputeDropdownChoices = (text) => {\n    const newState = {\n      choices: generateChoices(text, mainState),\n      index: 0, // reset index to 0\n    };\n    realizeChoice(newState);\n    return newState;\n  };\n\n  const adjustDropdownIndex = (amount) => {\n    setDropdownState(oldState => {\n      const newState = {\n        ...oldState,\n        index: (oldState.index + amount + oldState.choices.length) % oldState.choices.length,\n      };\n      realizeChoice(newState);\n      return newState;\n    });\n  };\n\n  const [dropdownState, setDropdownState] = useState(() => recomputeDropdownChoices(text));\n\n  const onChange = e => {\n    const newText = e.target.value;\n\n    if (newText === '[') {\n      // This is a special case, we bypass the normal dropdown/choice stuff\n      dispatch({type: 'END_EXPRESSION_EDIT'});\n      dispatch({type: 'CREATE_ARRAY'});\n    } else {\n      setText(newText);\n      setDropdownState(recomputeDropdownChoices(newText));\n    }\n  };\n\n  const onKeyDown = e => {\n    switch (e.key) {\n      case 'ArrowUp':\n        e.preventDefault(); // we don't want the default behavior of moving the cursor\n        adjustDropdownIndex(-1);\n        break;\n\n      case 'ArrowDown':\n        e.preventDefault(); // we don't want the default behavior of moving the cursor\n        adjustDropdownIndex(1);\n        break;\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n  return (\n    <div>\n      <input className=\"Editor-text-edit-input\" value={text} onChange={onChange} onKeyDown={onKeyDown} autoFocus />\n      <ul className=\"ExpressionChooser-dropdown\">\n        {dropdownState.choices.map((choice, idx) =>\n          <li key={idx} className={(idx === dropdownState.index) ? 'ExpressionChooser-dropdown-selected' : ''} ref={(idx === dropdownState.index) ? selectedListElem : undefined}><Choice choice={choice} /></li>\n        )}\n      </ul>\n    </div>\n  );\n}\n","import React from 'react';\nimport './Simple.css';\n\nfunction addSelection(selected, cns = '') {\n  return selected ? (cns + ' SimpleTheme-selected') : cns;\n}\n\nexport const generateTheme = ({ expressionGrouping, applicationArguments }) => ({\n  Program: ({ expressions }) => (\n    <div className=\"SimpleTheme-program\">{expressions}</div>\n  ),\n\n  Application: ({ functionName, streamArgs, functionArgs }) => {\n    const appClass = ((applicationArguments === 'right') || (applicationArguments === 'right-centered')) ? 'SimpleTheme-application-flex' : '';\n    const nameClass = 'SimpleTheme-application-function-name' + ((applicationArguments === 'right-centered') ? ' SimpleTheme-application-function-name-centered' : '');\n    return (\n      <div className={appClass}>\n        <div className={nameClass}>{functionName}</div>\n        <div className=\"SimpleTheme-application-arguments\">\n          {streamArgs.map(({key, name, expression}) => (\n            <div className=\"SimpleTheme-application-argument\" key={key}>{name ? <span className=\"SimpleTheme-application-argument-name\">{name}:</span> : null}<span className=\"SimpleTheme-application-argument-expression\">{expression}</span></div>\n          ))}\n          {functionArgs.map(({key, name, functionExpression}) => (\n            <div className=\"SimpleTheme-application-argument\" key={key}>{functionExpression}</div>\n          ))}\n        </div>\n      </div>\n    );\n  },\n\n  UserFunction: ({ parameterNames, expressions, selected }) => (\n    <div className={addSelection(selected, 'SimpleTheme-user-function')}>\n      <div>F {parameterNames.join(', ')}</div>\n      <div className=\"SimpleTheme-user-function-expressions\">{expressions}</div>\n    </div>\n  ),\n\n  DefinitionExpression: ({ expression }) => (\n    <div className=\"SimpleTheme-definition-expression\">{expression}</div>\n  ),\n\n  Expression: ({ identifier, selected, inside }) => (\n    <div className={addSelection(selected, 'SimpleTheme-expression')}>\n      { (() => {\n        switch (expressionGrouping) {\n          case 'line':\n            return (\n              <div className=\"SimpleTheme-expression-line\" />\n            );\n\n          case 'bracket':\n            return (\n              <div className=\"SimpleTheme-expression-bracket\" />\n            );\n\n          default:\n            return null;\n        }\n      })() }\n      <div>\n        {identifier ? <div className=\"SimpleTheme-expression-identifier\">{identifier}</div> : null}\n        <div className=\"SimpleTheme-expression-main\">{inside}</div>\n      </div>\n    </div>\n  ),\n\n  Identifier: ({ selected, inside }) => (\n    <span className={addSelection(selected, 'SimpleTheme-identifier')}>{inside}</span>\n  ),\n\n  StreamReference: ({ name }) => (\n    <div><span className=\"SimpleTheme-stream-reference\">{name}</span></div>\n  ),\n\n  UndefinedExpression: () => (\n    <div className=\"SimpleTheme-undefined-expression\">&nbsp;</div>\n  ),\n\n  ArrayLiteral: ({ keyedItems }) => (\n    <div>\n      <div>[</div>\n      <div className=\"SimpleTheme-array-items\">\n        {keyedItems.map(([key, item]) => (\n          <div className=\"SimpleTheme-array-item\" key={key}>{item}</div>\n        ))}\n      </div>\n      <div>]</div>\n    </div>\n  ),\n});\n","import React, { useState } from 'react';\nimport { generateTheme } from './themes/Simple';\nimport './ThemePicker.css';\n\nconst INITIAL_OPTIONS = {\n  expressionGrouping: 'line',\n  applicationArguments: 'below',\n};\n\nexport const INITIAL_THEME = generateTheme(INITIAL_OPTIONS);\n\nfunction Select({ keyLabels, selectedKey, onChange }) {\n  return (\n    <select value={selectedKey} onChange={evt => { onChange(evt.target.value) }}>\n      {keyLabels.map(([key, label]) => <option key={key} value={key}>{label}</option>)}\n    </select>\n  )\n}\n\nexport function ThemePicker({ onChange }) {\n  const [options, setOptions] = useState(INITIAL_OPTIONS);\n\n  const update = (newOptions) => {\n    setOptions(newOptions);\n    onChange(generateTheme(newOptions));\n  };\n\n  return (\n    <div className=\"ThemePicker\">\n      <div className=\"ThemePicker-option\"><label>Expression Grouping: <Select keyLabels={[\n        ['none', 'None'],\n        ['line', 'Line'],\n        ['bracket', 'Bracket'],\n      ]} selectedKey={options.expressionGrouping} onChange={v => update({ ...options, expressionGrouping: v })} /></label></div>\n      <div className=\"ThemePicker-option\"><label>Application Arguments: <Select keyLabels={[\n        ['below', 'Below'],\n        ['right', 'Right'],\n        ['right-centered', 'Right (centered)'],\n      ]} selectedKey={options.applicationArguments} onChange={v => update({ ...options, applicationArguments: v })} /></label></div>\n    </div>\n  );\n}\n\n/*\n<label>Theme:\n            <select value={theme} onChange={evt => { setTheme(evt.target.value) }}>{THEMES.map(([name, ]) => <option key={name} value={name}>{name}</option>)}</select>\n          </label>\n*/\n","import React, { createContext, useContext, useReducer, useRef, useEffect, useState } from 'react';\nimport { HotKeys, ObserveKeys } from \"react-hotkeys\";\nimport { initialState, reducer, nodeFromPath } from './EditReducer';\nimport ExpressionChooser from './ExpressionChooser';\nimport { INITIAL_THEME, ThemePicker } from './ThemePicker';\nimport './Editor.css';\n\nconst keyMap = {\n  MOVE_UP: 'up',\n  MOVE_DOWN: 'down',\n  MOVE_LEFT: 'left',\n  MOVE_RIGHT: 'right',\n\n  ZOOM_IN: 'shift+right',\n  ZOOM_OUT: 'shift+left',\n\n  TOGGLE_EDIT: 'enter',\n\n  EDIT_AFTER: ['shift+enter', ','],\n\n  DELETE: 'backspace',\n\n  BEGIN_EXPRESSION_IDENTIFIER_EDIT: '=',\n};\n\n// These are \"normal\" character keys that we use as commands. We identify them because we don't want\n// them to begin a \"overwrite edit\".\nconst COMMAND_CHARS = new Set([\n  '=',\n  ',',\n]);\n\n// By default, if an input element is focused, keys will be ignored. But we want some\n// of them to be processed even when an input is focused, and those ones are listed here.\n// Note that react-hotkeys only lets us list the individual keys here not \"combinations\"\n// as we would want.\nconst CATCH_IN_INPUTS = [\n  'Enter',\n  'Shift',\n  '=',\n  ',',\n];\n\nconst DispatchContext = createContext();\n\nconst SelectedNodeContext = createContext();\nfunction useIsSelected(obj) {\n  const selectedNode = useContext(SelectedNodeContext);\n  return obj === selectedNode;\n}\n\nconst FullStateContext = createContext();\n\nconst ThemeContext = createContext();\n\nfunction ProgramView({ program }) {\n  const { Program } = useContext(ThemeContext);\n\n  return <Program expressions={<DefinitionExpressionsView expressions={program.mainDefinition.expressions} />} />;\n}\n\nfunction DefinitionExpressionsView({ expressions }) {\n  const { DefinitionExpression } = useContext(ThemeContext);\n\n  return (\n    <>\n      {expressions.map((expression) => (\n        <div key={expression.streamId}>\n          <DefinitionExpression expression={<ExpressionView expression={expression} />} />\n        </div>\n      ))}\n    </>\n  )\n}\n\nfunction IdentifierChooser({ initialName, onUpdateName, onEndEdit }) {\n  const [text, setText] = useState(initialName || '');\n\n  const handleChange = e => {\n    const newText = e.target.value;\n    setText(newText);\n    if (onUpdateName) {\n      onUpdateName(newText);\n    }\n  };\n\n  const handleKeyDown = e => {\n    switch (e.key) {\n      case 'Enter':\n        e.stopPropagation();\n        if (onEndEdit) {\n          onEndEdit();\n        }\n        break;\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n  return <input className=\"Editor-text-edit-input\" value={text} onChange={handleChange} onKeyDown={handleKeyDown} autoFocus />;\n}\n\nfunction ExpressionIdentifierView({ expression }) {\n  const identifier = expression.identifier;\n  const selected = useIsSelected(identifier);\n  const {editingSelected} = useContext(FullStateContext);\n  const dispatch = useContext(DispatchContext);\n\n  const handleUpdateName = (name) => {\n    dispatch({\n      type: 'UPDATE_NODE',\n      newNode: {\n        type: 'Identifier',\n        name,\n      },\n    });\n  };\n\n  const handleEndEdit = () => {\n    dispatch({type: 'END_EXPRESSION_IDENTIFIER_EDIT'});\n  };\n\n  const { Identifier } = useContext(ThemeContext);\n\n  return <Identifier selected={selected} inside={(selected && editingSelected)\n    ? <IdentifierChooser initialName={identifier.name} onUpdateName={handleUpdateName} onEndEdit={handleEndEdit} />\n    : identifier.name\n  } />;\n}\n\nfunction IntegerLiteralView({ integerLiteral }) {\n  return <div>{integerLiteral.value}</div>;\n}\n\nfunction ArrayLiteralView({ arrayLiteral }) {\n  const { ArrayLiteral } = useContext(ThemeContext);\n\nreturn <ArrayLiteral keyedItems={arrayLiteral.items.map(item => [item.streamId, <ExpressionView expression={item} />])} />\n}\n\nfunction UndefinedExpressionView({ undefinedExpression }) {\n  const { UndefinedExpression } = useContext(ThemeContext);\n  return <UndefinedExpression />\n}\n\nfunction StreamReferenceView({ streamReference }) {\n  const {streamIdToNode} = useContext(FullStateContext).derivedLookups;\n  const targetExpressionNode = streamIdToNode.get(streamReference.targetStreamId);\n  if (!targetExpressionNode) {\n    throw new Error();\n  }\n\n  const { StreamReference } = useContext(ThemeContext);\n  return <StreamReference name={(targetExpressionNode.identifier && targetExpressionNode.identifier.name) ? targetExpressionNode.identifier.name : '<stream ' + streamReference.targetStreamId + '>'} />;\n}\n\nfunction UserFunctionView({ userFunction }) {\n  const selected = useIsSelected(userFunction);\n  const { UserFunction } = useContext(ThemeContext);\n\n  return (\n    <UserFunction parameterNames={userFunction.parameters.map(param => param.identifier.name)} expressions={<DefinitionExpressionsView expressions={userFunction.expressions} />} selected={selected} />\n  );\n}\n\nfunction ApplicationView({ application }) {\n  const {functionIdToNode} = useContext(FullStateContext).derivedLookups;\n  const functionNode = functionIdToNode.get(application.functionId);\n  if (!functionNode) {\n    throw new Error();\n  }\n\n  if (functionNode.signature.parameters.length !== application.arguments.length) {\n    throw new Error('params and args length mismatch');\n  }\n\n  if (functionNode.signature.functionParameters.length !== application.functionArguments.length) {\n    throw new Error('function params and args length mismatch');\n  }\n\n  const functionName = (functionNode.identifier && functionNode.identifier.name) ? functionNode.identifier.name : '<function ' + application.functionId + '>';\n  const streamArgs = functionNode.signature.parameters.map((paramName, idx) => ({\n    key: paramName,\n    name: paramName.startsWith('_') ? undefined : paramName,\n    expression: <ExpressionView expression={application.arguments[idx]} />\n  }));\n  const functionArgs = functionNode.signature.functionParameters.map(([paramName, signature], idx) => ({\n    key: paramName,\n    name: 'dunno',\n    functionExpression: <UserFunctionView userFunction={application.functionArguments[idx]} />\n  }));\n\n  const { Application } = useContext(ThemeContext);\n\n  return <Application functionName={functionName} streamArgs={streamArgs} functionArgs={functionArgs} />;\n}\n\nfunction NotEditingExpressionView({ expression }) {\n  switch (expression.type) {\n    case 'IntegerLiteral':\n      return <IntegerLiteralView integerLiteral={expression} />\n\n    case 'ArrayLiteral':\n      return <ArrayLiteralView arrayLiteral={expression} />\n\n    case 'UndefinedExpression':\n      return <UndefinedExpressionView undefinedExpression={expression} />\n\n    case 'StreamReference':\n      return <StreamReferenceView streamReference={expression} />\n\n    case 'Application':\n      return <ApplicationView application={expression} />\n\n    default:\n      throw new Error();\n  }\n}\n\nfunction ExpressionView({ expression }) {\n  const selected = useIsSelected(expression);\n  const mainState = useContext(FullStateContext);\n  const editingSelected = mainState.editingSelected;\n  const dispatch = useContext(DispatchContext);\n  const { Expression } = useContext(ThemeContext);\n\n  return <Expression identifier={expression.identifier ? <ExpressionIdentifierView expression={expression} /> : null} selected={selected} inside={\n    (selected && editingSelected)\n      ? <ExpressionChooser node={expression} mainState={mainState} dispatch={dispatch} />\n      : <NotEditingExpressionView expression={expression} />\n  } />;\n}\n\nexport default function Editor({ autoFocus }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const [theme, setTheme] = useState(INITIAL_THEME);\n\n  const editorElem = useRef();\n\n  // Do auto-focus if prop is set\n  const [constAutoFocus] = useState(autoFocus);\n  useEffect(() => {\n    if (constAutoFocus) {\n      // Focus editor after initial render\n      editorElem.current.focus();\n    }\n  }, [constAutoFocus]);\n\n  // Restore focus to editor elem if input box just went away.\n  // NOTE: This is hacky, but don't know better way to handle.\n  const previouslyEditingSelected = useRef(false);\n  useEffect(() => {\n    if (previouslyEditingSelected.current && !state.editingSelected) {\n      editorElem.current.focus();\n    }\n    previouslyEditingSelected.current = state.editingSelected;\n  });\n\n  // TODO: memoize generation of this\n  const handlers = {};\n  for (const k of Object.keys(keyMap)) {\n    handlers[k] = (() => (e) => {\n      e.preventDefault(); // If we attempted to handle this, prevent default (scrolling window, entering character, etc.)\n      dispatch({type: k});\n    })(); // IIFE to bind k\n  }\n\n  const onKeyDown = e => {\n    // TODO: This is not a robust check, but the spec is complicated\n    // (https://www.w3.org/TR/uievents-key/#keys-whitespace)\n    if ((e.target.tagName.toLowerCase() !== 'input') && ([...e.key].length === 1) && !e.altkey && !e.ctrlKey && !e.metaKey && !COMMAND_CHARS.has(e.key)) {\n      // Interestingly, the key here will still end up going into the input element, which is what we want.\n      dispatch({type: 'BEGIN_OVERWRITE_EDIT'});\n    }\n  };\n\n  return (\n    <HotKeys keyMap={keyMap} handlers={handlers}>\n      <ObserveKeys only={CATCH_IN_INPUTS}>\n        <div className=\"Editor\" onKeyDown={onKeyDown} tabIndex=\"0\" ref={editorElem}>\n          <div className=\"Editor-theme-controls\"><ThemePicker onChange={newTheme => { setTheme(newTheme) }} /></div>\n          <DispatchContext.Provider value={dispatch}>\n            <SelectedNodeContext.Provider value={nodeFromPath(state.program, state.selectionPath)}>\n              <FullStateContext.Provider value={state}>\n                <ThemeContext.Provider value={theme}>\n                  <ProgramView program={state.program} />\n                </ThemeContext.Provider>\n              </FullStateContext.Provider>\n            </SelectedNodeContext.Provider>\n          </DispatchContext.Provider>\n        </div>\n      </ObserveKeys>\n    </HotKeys>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport Editor from './Editor';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Editor autoFocus={true} />\n      <div>\n        <h2>Notes</h2>\n        <ul>\n          <li>If you don't see a green selection/cursor box, focus the editor.</li>\n          <li>There's no mouse/touch support yet, only keyboard.</li>\n          <li>Up/down arrows move selection up and down within lists (expressions, arguments, arrays).</li>\n          <li>Right/left arrows move selection in and out of nested structures.</li>\n          <li>Enter on an expression (or expression sub-tree) will begin editing it. Pressing enter again will stop editing.</li>\n          <li>Instead of pressing enter, you can just start typing letters/numbers and it will begin the edit (overwriting what it there).</li>\n          <li>Shift-enter (or comma) adds a new expression (or array item) below the current one.</li>\n          <li>Pressing the = key on on an expression will move to editing its name/label.</li>\n          <li>A red box indicates an undefined expression.</li>\n          <li>Delete will delete expressions, array items, etc.</li>\n          <li>Typing [ when editing an expression will create an array literal.</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}