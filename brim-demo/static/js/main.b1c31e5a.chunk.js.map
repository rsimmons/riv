{"version":3,"sources":["../../riv-runtime/lib/index.js","../../riv-demo-lib/src/index.js","../../riv-snabbdom/src/index.js","State.ts","uid.ts","Environment.ts","Traversal.ts","Compiler.ts","globalNatives.ts","EditReducer.ts","LiveFunction.ts","vendor/fts_fuzzy_match.js","ExpressionChooser.js","StoragePanel.js","themes/Simple.js","ThemePicker.js","Editor.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["Object","defineProperty","exports","value","currentUpdateFrame","ExecutionContext","streamFunc","onRequestUpdate","afterTerminate","this","hookRecordChain","data","cleanup","next","recordCursor","openRecord","updateCount","prototype","update","args","_i","arguments","length","retval","executionContext","previousFrame","apply","Error","poppedFrame","terminate","c","_beginHook","_endHook","_requestUpdate","_setStreamFunc","newStreamFunc","currentBatch","enqueueBatchedUpdate","callback","callbacks","add","getTopUpdatingExecutionContext","useVar","initVal","ctx","record","actualInitVal","Function","current","useRequestUpdate","requestUpdate","useEventReceiver","stream","queue_1","data_1","queue","lastStream","unsubscribe","onValue","push","recordData","subscribe","pop","beginBatch","Set","endBatch","forEach","cb","createNullaryVoidRootExecutionContext","updateCtx","t0","performance","now","dt","console","log","toFixed","useInitialize","initializer","useEventEmitter","subscribers_1","delete","emit","sub","useDynamic","oru_1","data_2","activeContexts","createContext","useReducer","evts","reducerFunc","initialState","state","evt","useReducers","streamReducerPairs","numStreams","evtCount","streamReducerPairs_1","_a","reducer","useCallbackReducer","action","useCallbackReducers","reducerFuncs","map","useMachine","states","initialTransition","takeTransition","trans","activeContext","newState","newStateArg","newCtx","activeState","activeArgument","data_3","tmpRetval","transition","__webpack_require__","r","__webpack_exports__","d","showString","animationFrameEvts","latestValue","animationTime","countEvents","mouseClickEvts","mouseDown","mousePosition","random","audioDriver","sampleUpon","everySecond","loadAudioAsArray","integral","expFollow","redCircle","followAtSpeed2d","eventAfter","received","streamMap","changeCount","_Users_russ_proj_riv_packages_brim_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__","_require","_require2","renderDOMAppendedToBody","h","v","vnode","style","border","color","fontSize","padding","marginTop","undefined","toString","reqId","_useEventEmitter","_useEventEmitter2","frameEvts","emitFrame","requestAnimationFrame","onFrame","t","cancelAnimationFrame","initialValue","_","previousCount","domEvts","eventTarget","type","extra","_useEventEmitter9","_useEventEmitter10","onEvent","e","document","addEventListener","removeEventListener","downEvts","upEvts","inputEvts","inputEvt","_useEventEmitter3","_useEventEmitter4","outputEvts","emitOutput","mapEvts","x","y","repickEvts","Math","generator","createGenerator","generatorCtx","frameCount","sampleRate","_useEventEmitter11","_useEventEmitter12","advanceFrameEvts","emitAdvanceFrameEvt","audioContext","window","AudioContext","webkitAudioContext","scriptNode","createScriptProcessor","onaudioprocess","buffer","outputBuffer","getChannelData","i","frameVal","Number","isNaN","connect","destination","disconnect","close","toSample","uponEvts","_useEventEmitter13","_useEventEmitter14","tickEvts","emitTick","timerId","setInterval","clearInterval","url","pcm","audioCtx","cleanedUp","request","XMLHttpRequest","open","responseType","onload","audioData","response","decodeAudioData","send","abort","integrandFunc","time","accum","prevTime","integrand","targetValue","speedConstant","currentValue","position","radius","p","halfRadius","borderRadius","background","pointerEvents","userSelect","left","top","width","height","target","speed","initial","pos","delta","dist","sqrt","seconds","valueToEmit","_useEventEmitter15","_useEventEmitter16","setTimeout","clearTimeout","previousState","event","f","arr","createFContext","fContexts","s","a","b","count","previous","renderDOMIntoElement","renderDOMIntoSelector","riv_runtime__WEBPACK_IMPORTED_MODULE_0__","patch","init","default","cloneNode","sel","children","text","key","elm","containerElement","savedContainerElement","previousVnode","clonedVnode","innerHTML","elem","createElement","appendChild","containerSelector","querySelector","body","removeChild","isIdentifierNode","node","isArrayLiteralNode","isApplicationNode","isParameterNode","isExpressionNode","isUndefinedExpressionNode","isIntegerLiteralNode","isStreamReferenceNode","isUserFunctionNode","isFunctionNode","isNativeFunctionNode","pathIsPrefix","gen32","substring","uid","Environment","outer","classCallCheck","obj","create","name","traverseTree","options","visit","_recursiveTraverseTre15","recursiveTraverseTree","path","alongPath","exited","newNode","identifier","_recursiveTraverseTre","concat","_recursiveTraverseTre2","slicedToArray","exit","newIdentifier","objectSpread","_recursiveTraverseTre3","mainDefinition","_recursiveTraverseTre4","newMainDefinition","newParameters","newExpressions","anyNewChildren","parameters","parameter","idx","_recursiveTraverseTre5","_recursiveTraverseTre6","newParameter","expressions","expression","_recursiveTraverseTre7","_recursiveTraverseTre8","newExpression","newArguments","newFunctionArguments","argument","_recursiveTraverseTre9","_recursiveTraverseTre10","newArgument","functionArguments","functionArgument","onlyLocal","_recursiveTraverseTre11","_recursiveTraverseTre12","newFunctionArgument","newItems","items","item","_recursiveTraverseTre13","_recursiveTraverseTre14","newItem","CompilationError","_Error","possibleConstructorReturn","getPrototypeOf","inherits","wrapNativeSuper","traverseFromExpression","context","streamEnvironment","functionEnvironment","localStreamIds","temporaryMarkedStreamIds","permanentMarkedStreamIds","compiledDefinition","has","streamId","literalStreamValues","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","err","return","applications","targetStreamId","targetExpressionNode","get","externalReferencedStreamIds","functionNode","functionId","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","compiledContainedDef","compileUserDefinition","sid","depLocalExprNode","containedDefinitions","definition","outerStreamEnvironment","outerFunctionEnvironment","localFunctionIds","set","parameterStreams","param","yieldStream","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","require","nativeFunctions","functionParameters","cond","_then","_else","cos","size","spacing","vecs","SCHEMA_CLASSES","Expression","Any","nodeFromPath","root","cur","nodeSplitPath","seg","slice","addUserFunctionLocalEnvironment","func","namedStreams","namedFunctions","environmentForSelectedNode","extFunc","addEnvironmentAlongPath","program","selectionPath","equiv","JSON","stringify","deleteDefinitionExpression","removeIdx","toConsumableArray","newIdx","max","min","n","genuid","originalNode","tentativeNode","endEdit","_ref","confirm","subpath","editingSelected","newIdName","newIdNode","trim","newSubpath","newEditingSelected","hit","firstUndefinedNode","_hit","hitNode","hitPath","result","after","passed","HANDLERS","_ref2","newName","_ref3","newExpressionIdx","_ref4","_ref5","_ref6","_ref7","idNode","_ref8","_ref9","_ref10","afterIdx","insertingExprNode","_ref11","_ref12","newExprNode","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","applyActionToProgram","handled","newSelectionPath","newProgram","_HANDLERS","_ref24","_ref23","nt","acts","hfunc","includes","_nodeSplitPath","_nodeSplitPath2","pathBefore","handlerResult","_handlerResult","handlerNewNode","handlerNewSubpath","handlerNewEditingSelected","addStateIdLookups","streamIdToNode","Map","functionIdToNode","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","derivedLookups","nodeToPath","computeNodeToPathMap","addStateCompiled","oldState","newLiveMain","newCompiledDefinition","globalFunctionEnvironment","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","nf","compileGlobalUserDefinition","message","_ref25","liveMain","updateCompiledDefinition","_createLiveFunction","createLiveFunction","initialDefinition","activations","activation","applicationContext","fid","updateContainedDefinition","_createLiveFunction2","sf","updateDef","_activation$current","streamEnv","funcEnv","appCtx","argIds","fargIds","argVals","appVal","newDefinition","oldLiteralMap","newLiteralMap","_ref37","val","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_ref38","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_loop","_iterator8","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_loop2","_iterator9","oldAppMap","newAppMap","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","_ref39","_ref22","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","_ref40","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_step12","_loop3","_iterator12","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_step13","_loop4","_ref27","_ref28","funcId","createNew","oldApp","_oldApp","oldFuncId","oldArgs","arraysShallowEqual","_iterator13","oldDefMap","newDefMap","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_step14","_iterator14","_ref41","_ref30","def","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_step15","_iterator15","_ref42","_ref32","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_step16","_loop5","_ref33","_iterator16","_iteratorNormalCompletion17","_didIteratorError17","_iteratorError17","_step17","_loop6","_ref35","_ref36","_createLiveFunction3","_createLiveFunction4","_iterator17","nativeFunctionEnvironment","liveStreamFunc","addDerivedState","danglingRemovedState","undefineDanglingStreamRefs","initialStateFromProgram","newUndoStack","undoStack","newClipboardStack","clipboardStack","_applyActionToProgram","_applyActionToProgram2","topFrame","selectedNode","mode","_cutExpressionNode","cutNode","holeNode","selectionPathAfter","cutExpressionNode","_cutExpressionNode2","_pasteExpressionNode","pasteNode","pasteStreamId","expr","_deleteDefinitionExpr","pasteExpressionNode","_pasteExpressionNode2","newSelectedNode","newPath","_hit2","_applyActionToProgram3","_applyActionToProgram4","globalNativeFunctions","_ref29","signature","Array","of","_ref26","id","jsFunc","mdId","functionParameterFunctionIds","fuzzy_match","pattern","str","score","patternIdx","patternLength","strIdx","strLength","prevMatched","prevLower","prevSeparator","bestLetter","bestLower","bestLetterIdx","bestLetterScore","matchedIndices","patternChar","charAt","strChar","patternLower","toLowerCase","strLower","strUpper","toUpperCase","nextMatch","rematch","newScore","formattedStr","lastIdx","substr","fuzzySearch","query","results","_fuzzy_match","_fuzzy_match2","sort","FLOAT_REGEX","generateChoices","mainState","choices","_environmentForSelect","streamSearchResults","functionSearchResults","test","Choice","choice","react_default","startsWith","join","ExpressionChooser","dispatch","selectedListElem","useRef","useEffect","scrollIntoView","block","inline","_useState","useState","initFromNode","_useState2","setText","realizeChoice","index","paramName","pn","recomputeDropdownChoices","adjustDropdownIndex","amount","setDropdownState","_useState3","_useState4","dropdownState","className","onChange","newText","onKeyDown","preventDefault","autoFocus","ref","StoragePanel","currentProgram","onChangeName","onLoadProgram","ls","localStorage","selectedProgramId","setSelectedProgramId","savedPrograms","setSavedPrograms","refreshSavedPrograms","setProgramId","newProgramId","sp","k","parse","getItem","prog","selectRef","onClick","json","setItem","disabled","removeItem","Selectable","marks","onSelect","onEdit","extraClassName","hovered","setHovered","tagName","stopPropagation","onDoubleClick","onMouseOver","onMouseOut","generateTheme","expressionGrouping","applicationArguments","Application","functionName","streamArgs","functionArgs","appClass","nameClass","functionExpression","UserFunction","parameterNames","DefinitionExpression","inside","exprClass","Identifier","StreamReference","UndefinedExpression","ArrayLiteral","keyedItems","INITIAL_OPTIONS","INITIAL_THEME","Select","keyLabels","selectedKey","label","ThemePicker","setOptions","newOptions","keyMap","MOVE_UP","MOVE_DOWN","MOVE_LEFT","MOVE_RIGHT","ZOOM_IN","ZOOM_OUT","TOGGLE_EDIT","ABORT_EDIT","EDIT_AFTER","DELETE","BEGIN_IDENTIFIER_EDIT","EDIT_NEXT_UNDEFINED","UNDO","CUT","PASTE","COMMAND_CHARS","CATCH_IN_INPUTS","FullStateContext","DispatchContext","MarkedNodesContext","useMarks","_useContext","useContext","clipboardTopNode","clipboardRestNodes","useHandleSelect","ThemeContext","DefinitionExpressionsView","Fragment","ExpressionView","IdentifierChooser","initialName","onUpdateName","onEndEdit","IdentifierView","handleSelect","IntegerLiteralView","integerLiteral","ArrayLiteralView","arrayLiteral","UndefinedExpressionView","undefinedExpression","StreamReferenceView","streamReference","UserFunctionView","userFunction","ApplicationView","application","NotEditingExpressionView","handleEdit","useHandleEdit","ExpressionChooser_ExpressionChooser","Editor","_useReducer","_useReducer2","theme","setTheme","editorElem","_useState5","constAutoFocus","focus","previouslyEditingSelected","handlers","_Object$keys","keys","markedNodes","frame","index_es","only","altkey","ctrlKey","metaKey","tabIndex","ThemePicker_ThemePicker","newTheme","Provider","StoragePanel_StoragePanel","App","Editor_Editor","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b1c31e5a.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar currentUpdateFrame = null;\n\nvar ExecutionContext =\n/** @class */\nfunction () {\n  function ExecutionContext(streamFunc, onRequestUpdate, afterTerminate) {\n    if (afterTerminate === void 0) {\n      afterTerminate = null;\n    }\n\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      data: null,\n      cleanup: null,\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.openRecord = null;\n    this.updateCount = 0;\n  }\n\n  ExecutionContext.prototype.update = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Push a new update frame onto the update stack for this context\n\n\n    var newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    var retval;\n\n    try {\n      retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn't get to, and something is amiss\n\n      if (this.recordCursor.next) {\n        throw new Error('Did not reach all hook records in update');\n      }\n    } finally {\n      // Pop the top frame from the update stack\n      var poppedFrame = currentUpdateFrame;\n\n      if (!poppedFrame) {\n        throw new Error('Cannot pop update frame because current is null');\n      }\n\n      if (poppedFrame.executionContext !== this) {\n        throw new Error(\"Popped frame from update stack but context did not match\");\n      }\n\n      currentUpdateFrame = poppedFrame.previousFrame;\n    }\n\n    this.updateCount++;\n    return retval;\n  };\n\n  ExecutionContext.prototype.terminate = function () {\n    // NOTE: Might we want to sanity check that this context isn't anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (var c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  };\n\n  ExecutionContext.prototype._beginHook = function () {\n    if (this.openRecord) {\n      throw new Error('This is already an open hook when beginning another');\n    }\n\n    if (!this.recordCursor) {\n      throw new Error();\n    }\n\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error('Expecting to create new hook record in chain, but already present');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: null,\n        cleanup: null,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error('Expecting to find hook record in chain, but not present');\n    }\n\n    this.openRecord = this.recordCursor.next;\n    return this.recordCursor.next;\n  };\n\n  ExecutionContext.prototype._endHook = function () {\n    if (!this.recordCursor) {\n      throw new Error();\n    }\n\n    if (this.openRecord !== this.recordCursor.next) {\n      throw new Error('Hook close does not match open');\n    }\n\n    this.openRecord = null;\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  };\n\n  ExecutionContext.prototype._requestUpdate = function () {\n    this.onRequestUpdate();\n  };\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It's currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  ExecutionContext.prototype._setStreamFunc = function (newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  };\n\n  return ExecutionContext;\n}();\n\nexports.ExecutionContext = ExecutionContext;\nvar currentBatch = null;\n\nfunction beginBatch() {\n  if (currentBatch) {\n    throw new Error('cannot begin batch when one is already active');\n  }\n\n  currentBatch = {\n    callbacks: new Set()\n  };\n}\n\nexports.beginBatch = beginBatch;\n\nfunction endBatch() {\n  if (!currentBatch) {\n    throw new Error('cannot end batch when none is active');\n  }\n\n  currentBatch.callbacks.forEach(function (cb) {\n    cb();\n  });\n  currentBatch = null;\n}\n\nexports.endBatch = endBatch;\n\nfunction enqueueBatchedUpdate(callback) {\n  if (currentBatch) {\n    currentBatch.callbacks.add(callback);\n  } else {\n    // NOTE: If there is no current batch, we just call the callback immediately\n    callback();\n  }\n}\n\nexports.enqueueBatchedUpdate = enqueueBatchedUpdate;\n\nfunction createNullaryVoidRootExecutionContext(streamFunc) {\n  var updateCount = 0;\n\n  var updateCtx = function updateCtx() {\n    var t0 = performance.now();\n    ctx.update();\n    var dt = performance.now() - t0;\n    updateCount++;\n    console.log('root update', 'count', updateCount, 'time', dt.toFixed(2) + 'ms');\n  };\n\n  var onRequestUpdate = function onRequestUpdate() {\n    enqueueBatchedUpdate(updateCtx);\n  };\n\n  var ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n\nexports.createNullaryVoidRootExecutionContext = createNullaryVoidRootExecutionContext;\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error('Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n/**\n * If initVal is a function, it will be called on first update to generate initial value.\n */\n\n\nfunction useVar(initVal) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    var actualInitVal = initVal instanceof Function ? initVal() : initVal;\n    record.data = {\n      current: actualInitVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n\nexports.useVar = useVar;\n/**\n * Why do we need a hook? Why can't we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: function requestUpdate() {\n        ctx._requestUpdate(); // it's important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\n\nexports.useRequestUpdate = useRequestUpdate;\n\nfunction useInitialize(initializer) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer() || null;\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\n\nexports.useInitialize = useInitialize;\n\nfunction useEventEmitter() {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    var subscribers_1 = new Set();\n    var stream = {\n      subscribe: function subscribe(onValue) {\n        subscribers_1.add(onValue);\n        return function () {\n          subscribers_1.delete(onValue);\n        };\n      }\n    };\n\n    var emit = function emit(value) {\n      subscribers_1.forEach(function (sub) {\n        sub(value);\n      });\n    };\n\n    record.data = {\n      stream: stream,\n      emit: emit\n    };\n  }\n\n  ctx._endHook();\n\n  return [record.data.stream, record.data.emit];\n}\n\nexports.useEventEmitter = useEventEmitter;\n\nfunction useEventReceiver(stream) {\n  ;\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    var queue_1 = [];\n    var data_1 = {\n      queue: queue_1,\n      lastStream: null,\n      unsubscribe: null,\n      onValue: function onValue(value) {\n        queue_1.push(value);\n      }\n    };\n    record.data = data_1;\n\n    record.cleanup = function () {\n      if (data_1.unsubscribe) {\n        data_1.unsubscribe();\n      }\n    };\n  }\n\n  var retval;\n  var recordData = record.data;\n\n  if (stream !== recordData.lastStream) {\n    // Stream changed identity\n    // I _think_ we want to disallow this, since semantics are unclear\n    if (recordData.queue.length) {\n      throw new Error('useEventReceiver stream changed, but value is in queue');\n    }\n\n    if (recordData.lastStream) {\n      if (!recordData.unsubscribe) {\n        throw new Error('should not be possible');\n      }\n\n      recordData.unsubscribe();\n      recordData.lastStream = null;\n      recordData.unsubscribe = null;\n    } // TODO: We could validate that it's either undefined or null or a valid stream object\n\n\n    recordData.lastStream = stream;\n\n    if (stream) {\n      recordData.unsubscribe = stream.subscribe(recordData.onValue);\n    }\n  } else {\n    // Stream did not change identity. Check if there is an value in the queue\n    if (recordData.queue.length) {\n      if (recordData.queue.length > 1) {\n        throw new Error('useEventReceiver found more than one enqueued value');\n      }\n\n      var eventValue = recordData.queue.pop(); // assertion is OK because we verified length is 1\n\n      retval = {\n        value: eventValue\n      };\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n\nexports.useEventReceiver = useEventReceiver;\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new \"version\" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    // If no onRequestUpdate is provided, default to requesting update on the current context\n    var oru_1 = onRequestUpdate || function () {\n      ctx._requestUpdate();\n    };\n\n    var data_2 = {\n      // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n      activeContexts: new Set(),\n      // Create \"factory\" function to instantiate new contexts\n      createContext: function createContext() {\n        var ctx = new ExecutionContext(data_2.streamFunc, oru_1, function () {\n          data_2.activeContexts.delete(ctx);\n        });\n        data_2.activeContexts.add(ctx);\n        return ctx;\n      },\n      streamFunc: function streamFunc() {\n        throw new Error('should be unreachable');\n      }\n    };\n    record.data = data_2;\n\n    record.cleanup = function () {\n      data_2.activeContexts.forEach(function (ctx) {\n        return ctx.terminate();\n      });\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n  record.data.activeContexts.forEach(function (ctx) {\n    ctx._setStreamFunc(streamFunc);\n  });\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}\n\nexports.useDynamic = useDynamic;\n/**\n * NOTE: reducerFunc should be pure-pointwise, NOT a stream func\n * If initialState is a function, it will be called on first update to generate initial state.\n */\n\nfunction useReducer(evts, reducerFunc, initialState) {\n  var state = useVar(initialState);\n  var evt = useEventReceiver(evts);\n\n  if (evt) {\n    state.current = reducerFunc(state.current, evt.value);\n  }\n\n  return state.current;\n}\n\nexports.useReducer = useReducer;\n/**\n * NOTE: streamReducerPairs must not change length.\n */\n\nfunction useReducers(streamReducerPairs, initialState) {\n  var state = useVar(initialState);\n  var numStreams = useVar(streamReducerPairs.length);\n\n  if (streamReducerPairs.length !== numStreams.current) {\n    // NOTE: We could allow this with some extra work\n    throw new Error('The number of streams/reducers supplied to useMultiReducer cannot change');\n  } // It's safe to call hook in this loop because we made sure that the length is the same\n\n\n  var evtCount = 0;\n\n  for (var _i = 0, streamReducerPairs_1 = streamReducerPairs; _i < streamReducerPairs_1.length; _i++) {\n    var _a = streamReducerPairs_1[_i],\n        evts = _a[0],\n        reducer = _a[1];\n    var evt = useEventReceiver(evts);\n\n    if (evt) {\n      if (evtCount > 0) {\n        // TODO: We _could_ handle these sequentially.. should we have a flag that says whether to allow or not?\n        throw new Error('useMultiReducer got multiple events, cannot merge');\n      }\n\n      state.current = reducer(state.current, evt.value);\n      evtCount++;\n    }\n  }\n\n  return state.current;\n}\n\nexports.useReducers = useReducers;\n/**\n * NOTE: reducerFunc should be pure-pointwise, NOT a stream func\n * If initialState is a function, it will be called on first update to generate initial state.\n */\n\nfunction useCallbackReducer(reducerFunc, initialState) {\n  var requestUpdate = useRequestUpdate();\n  var state = useVar(initialState); // We cache the callback, though I don't think we really need to?\n\n  var callback = useVar(function () {\n    return function (action) {\n      state.current = reducerFunc(state.current, action);\n      requestUpdate();\n    };\n  });\n  return [state.current, callback.current];\n}\n\nexports.useCallbackReducer = useCallbackReducer;\n\nfunction useCallbackReducers(reducerFuncs, initialState) {\n  var requestUpdate = useRequestUpdate();\n  var state = useVar(initialState);\n  var callbacks = reducerFuncs.map(function (reducerFunc) {\n    return function (action) {\n      state.current = reducerFunc(state.current, action);\n      requestUpdate();\n    };\n  });\n  return [state.current, callbacks];\n}\n\nexports.useCallbackReducers = useCallbackReducers;\n/**\n * TODO: Could/should this take an optional onRequestUpdate parameter?\n */\n\nfunction useMachine(states, initialTransition) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook();\n\n  var takeTransition = function takeTransition(trans) {\n    // If there's an old context, terminate it\n    if (record.data.activeContext) {\n      record.data.activeContext.terminate();\n    }\n\n    var newState = trans[0],\n        newStateArg = trans[1]; // Create a new context and store it in record (but don't update it)\n\n    var newCtx = new ExecutionContext(states[newState], function () {\n      ctx._requestUpdate();\n    });\n    record.data.activeState = newState;\n    record.data.activeContext = newCtx;\n    record.data.activeArgument = newStateArg;\n  };\n\n  if (!record.data) {\n    var data_3 = {\n      activeContext: null\n    };\n    record.data = data_3;\n    takeTransition(initialTransition); // this will set stuff in record.data\n\n    record.cleanup = function () {\n      if (!data_3.activeContext) {\n        throw new Error('should have been initialized');\n      }\n\n      data_3.activeContext.terminate();\n    };\n  }\n\n  var retval;\n\n  while (true) {\n    // Set the state function in the active context (in case it changed)\n    record.data.activeContext._setStreamFunc(states[record.data.activeState]); // Update the active context\n\n\n    var _a = record.data.activeContext.update(record.data.activeArgument),\n        tmpRetval = _a[0],\n        transition = _a[1];\n\n    retval = tmpRetval; // Did the state function return a transition to take?\n\n    if (transition) {\n      takeTransition(transition); // And loop again\n    } else {\n      // There was no transition\n      break;\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n\nexports.useMachine = useMachine;","import _toConsumableArray from \"/Users/russ/proj/riv/packages/brim/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/russ/proj/riv/packages/brim/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _require = require('riv-runtime'),\n    useVar = _require.useVar,\n    useRequestUpdate = _require.useRequestUpdate,\n    useInitialize = _require.useInitialize,\n    useEventEmitter = _require.useEventEmitter,\n    useEventReceiver = _require.useEventReceiver,\n    useDynamic = _require.useDynamic,\n    useReducer = _require.useReducer,\n    useReducers = _require.useReducers;\n\nvar _require2 = require('riv-snabbdom'),\n    renderDOMAppendedToBody = _require2.renderDOMAppendedToBody,\n    h = _require2.h;\n\nexport function showString(v) {\n  var vnode = h('div', {\n    style: {\n      border: '1px solid red',\n      color: 'black',\n      fontSize: '24px',\n      padding: '5px',\n      marginTop: '20px'\n    }\n  }, 'showString: ' + (v === undefined ? '(undefined)' : v.toString()));\n  renderDOMAppendedToBody(vnode);\n}\nexport function animationFrameEvts() {\n  var requestUpdate = useRequestUpdate();\n  var reqId = useVar();\n\n  var _useEventEmitter = useEventEmitter(),\n      _useEventEmitter2 = _slicedToArray(_useEventEmitter, 2),\n      frameEvts = _useEventEmitter2[0],\n      emitFrame = _useEventEmitter2[1];\n\n  useInitialize(function () {\n    var onFrame = function onFrame(t) {\n      emitFrame(0.001 * t);\n      requestUpdate();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return function () {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\nexport function latestValue(evts, initialValue) {\n  return useReducer(evts, function (_, value) {\n    return value;\n  }, initialValue);\n}\n\nfunction mapEvts(inputEvts) {\n  var inputEvt = useEventReceiver(inputEvts);\n\n  var _useEventEmitter3 = useEventEmitter(),\n      _useEventEmitter4 = _slicedToArray(_useEventEmitter3, 2),\n      outputEvts = _useEventEmitter4[0],\n      emitOutput = _useEventEmitter4[1];\n\n  if (inputEvt) {\n    emitOutput(inputEvt.value);\n  } // TODO: We don't need to request update since we are already being updated\n\n\n  return outputEvts;\n}\n\nfunction mergeEvts(streams) {\n  var _useEventEmitter5 = useEventEmitter(),\n      _useEventEmitter6 = _slicedToArray(_useEventEmitter5, 2),\n      outputEvts = _useEventEmitter6[0],\n      emitOutput = _useEventEmitter6[1]; // TODO: This is a hack that assumes array length never changes\n\n\n  var evts = _toConsumableArray(streams).map(function (stream) {\n    return useEventReceiver(stream);\n  }).filter(function (e) {\n    return e;\n  });\n\n  if (evts.length > 1) {\n    throw new Error('Failed to merge events since more than one present');\n  } else if (evts.length === 1) {\n    emitOutput(evts[0].value);\n  }\n\n  return outputEvts;\n}\n\nexport function animationTime() {\n  return latestValue(animationFrameEvts(), function () {\n    return 0.001 * performance.now();\n  });\n}\nexport function countEvents(evts) {\n  return useReducer(evts, function (previousCount) {\n    return previousCount + 1;\n  }, 0);\n}\n\nfunction makeAsyncCallback() {\n  var _useEventEmitter7 = useEventEmitter(),\n      _useEventEmitter8 = _slicedToArray(_useEventEmitter7, 2),\n      evts = _useEventEmitter8[0],\n      emit = _useEventEmitter8[1];\n\n  var requestUpdate = useRequestUpdate();\n\n  var callback = function callback() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    emit(args);\n    requestUpdate();\n  };\n\n  return [callback, evts];\n}\n\nfunction domEvts(eventTarget, type, extra) {\n  // TODO: We should cache type/extra\n  var requestUpdate = useRequestUpdate();\n\n  var _useEventEmitter9 = useEventEmitter(),\n      _useEventEmitter10 = _slicedToArray(_useEventEmitter9, 2),\n      evts = _useEventEmitter10[0],\n      emit = _useEventEmitter10[1];\n\n  useInitialize(function () {\n    var onEvent = function onEvent(e) {\n      emit(e);\n      requestUpdate();\n    };\n\n    document.addEventListener(type, onEvent, extra);\n    return function () {\n      // cleanup\n      document.removeEventListener(type, onEvent, extra);\n    };\n  });\n  return evts;\n}\n\nexport function mouseClickEvts() {\n  return domEvts(document, 'mousedown');\n}\nexport function mouseDown() {\n  var downEvts = domEvts(document, 'mousedown');\n  var upEvts = domEvts(document, 'mouseup');\n  return useReducers([[upEvts, function () {\n    return false;\n  }], [downEvts, function () {\n    return true;\n  }]], false); // We can't poll down-ness, so we assume it's initially not down\n}\nexport function mousePosition() {\n  return latestValue(mapEvts(domEvts(document, 'mousemove'), function (e) {\n    return {\n      x: e.clientX || e.pageX,\n      y: e.clientY || e.pageY\n    };\n  }), {\n    x: 0,\n    y: 0\n  });\n}\nexport function random(repickEvts) {\n  return useReducer(repickEvts, function () {\n    return Math.random();\n  }, function () {\n    return Math.random();\n  });\n}\nexport function audioDriver(generator) {\n  var createGenerator = useDynamic(generator);\n  var generatorCtx = useVar();\n  var frameCount = useVar(0);\n  var sampleRate = useVar();\n\n  var _useEventEmitter11 = useEventEmitter(),\n      _useEventEmitter12 = _slicedToArray(_useEventEmitter11, 2),\n      advanceFrameEvts = _useEventEmitter12[0],\n      emitAdvanceFrameEvt = _useEventEmitter12[1];\n\n  useInitialize(function () {\n    generatorCtx.current = createGenerator();\n    var BUFFER_SIZE = 1024;\n    var audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    var scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = function (e) {\n      var buffer = e.outputBuffer.getChannelData(0);\n\n      for (var i = 0; i < buffer.length; i++) {\n        emitAdvanceFrameEvt();\n        var frameVal = generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current);\n\n        if (!frameVal || Number.isNaN(frameVal)) {\n          frameVal = 0;\n        } else if (frameVal > 1) {\n          frameVal = 1;\n        } else if (frameVal < -1) {\n          frameVal = -1;\n        }\n\n        buffer[i] = frameVal;\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return function () {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current); // NOTE: we discard retval\n}\nexport function sampleUpon(toSample, uponEvts, initialValue) {\n  return useReducer(uponEvts, function () {\n    return toSample;\n  }, initialValue);\n}\nexport function everySecond() {\n  var requestUpdate = useRequestUpdate();\n\n  var _useEventEmitter13 = useEventEmitter(),\n      _useEventEmitter14 = _slicedToArray(_useEventEmitter13, 2),\n      tickEvts = _useEventEmitter14[0],\n      emitTick = _useEventEmitter14[1];\n\n  useInitialize(function () {\n    var onInterval = function onInterval() {\n      emitTick();\n      requestUpdate();\n    };\n\n    var timerId = setInterval(onInterval, 1000);\n    return function () {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvts;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\nexport function loadAudioAsArray(url) {\n  var requestUpdate = useRequestUpdate();\n  var pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(function () {\n    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    var cleanedUp = false;\n    var request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = function () {\n      var audioData = request.response;\n      audioCtx.decodeAudioData(audioData, function (buffer) {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return function () {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nexport function integral(integrandFunc, time) {\n  var initialValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var accum = useVar(initialValue);\n  var prevTime = useVar(time);\n  var integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\nexport function expFollow(targetValue, speedConstant, time, initialValue) {\n  return integral(function (currentValue) {\n    return speedConstant * (targetValue - currentValue);\n  }, time, initialValue);\n}\nexport function redCircle(position) {\n  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n  var p = position || {\n    x: 0,\n    y: 0\n  };\n\n  if (radius < 0) {\n    radius = 0;\n  }\n\n  var halfRadius = 0.5 * radius;\n  var vnode = h('div', {\n    style: {\n      position: 'absolute',\n      borderRadius: '50%',\n      background: 'red',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      left: p.x - halfRadius + 'px',\n      top: p.y - halfRadius + 'px',\n      width: radius + 'px',\n      height: radius + 'px'\n    }\n  });\n  renderDOMAppendedToBody(vnode);\n}\nexport function followAtSpeed2d(target, speed, time, initial) {\n  var pos = useVar(initial);\n  var prevTime = useVar(time);\n  var dt = time - prevTime.current;\n  var delta = {\n    x: target.x - pos.current.x,\n    y: target.y - pos.current.y\n  };\n  var dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n\n  if (speed * dt >= dist) {\n    // Jump to target position\n    pos.current = target;\n  } else {\n    // NOTE: We must not mutate pos.current, since we return that\n    pos.current = {\n      x: pos.current.x + dt * speed * delta.x / dist,\n      y: pos.current.y + dt * speed * delta.y / dist\n    };\n  }\n\n  prevTime.current = time;\n  return pos.current;\n}\n/**\n * Note that this _will_ fire in first call if condition starts truthy\n */\n\nfunction eventWhen(condition, valueToEmit) {\n  var prevCondition = useVar(false);\n  var bcond = !!condition;\n  var retval = bcond && !prevCondition.current ? {\n    value: valueToEmit\n  } : undefined;\n  prevCondition.current = bcond;\n  return retval;\n}\n/**\n * Note that seconds argument is only read initially. But valueToEmit is re-read on changes\n */\n\n\nexport function eventAfter(seconds, valueToEmit) {\n  var _useEventEmitter15 = useEventEmitter(),\n      _useEventEmitter16 = _slicedToArray(_useEventEmitter15, 2),\n      evts = _useEventEmitter16[0],\n      emit = _useEventEmitter16[1];\n\n  var value = useVar(valueToEmit);\n  value.current = valueToEmit;\n  useInitialize(function () {\n    var timerId = setTimeout(function () {\n      emit(value.current);\n    }, 1000 * seconds);\n    return function () {\n      clearTimeout(timerId);\n    };\n  });\n  return evts;\n}\nexport function received(evts) {\n  return useReducer(evts, function (previousState, event) {\n    return true;\n  }, false);\n}\n/**\n * F is a stream function that must stay hook-equivalent.\n */\n\nexport function streamMap(f) {\n  var arr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var createFContext = useDynamic(f);\n  var fContexts = useVar([]); // Create or destrooy contexts as needed to match arr length\n\n  while (arr.length > fContexts.current.length) {\n    fContexts.current.push(createFContext());\n  }\n\n  while (arr.length < fContexts.current.length) {\n    var ctx = fContexts.current.pop();\n    ctx.terminate();\n  }\n\n  var outs = fContexts.current.map(function (ctx, i) {\n    return ctx.update(arr[i]);\n  });\n  return outs;\n}\n\nfunction robustEquals(a, b) {\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  return a === b;\n}\n\nexport function changeCount(s) {\n  var count = useVar(0);\n  var previous = useVar(s);\n\n  if (!robustEquals(s, previous.current)) {\n    count.current++;\n  }\n\n  previous.current = s;\n  return count.current;\n}","import { useVar, useInitialize } from 'riv-runtime';\n\nvar snabbdom = require('snabbdom');\n\nvar patch = snabbdom.init([require('snabbdom/modules/class').default, require('snabbdom/modules/attributes').default, require('snabbdom/modules/style').default, require('snabbdom/modules/eventlisteners').default]);\nexport var h = require('snabbdom/h').default; // helper function for creating vnodes\n\nfunction cloneNode(vnode) {\n  return {\n    sel: vnode.sel,\n    data: vnode.data,\n    children: vnode.children && vnode.children.map(cloneNode),\n    text: vnode.text,\n    key: vnode.key,\n    elm: vnode.elm // I think this should be unset in our usage, since we only clone before passing to patch\n\n  };\n}\n/**\n * Note that element is only read upon init\n */\n\n\nexport function renderDOMIntoElement(vnode, containerElement) {\n  var savedContainerElement = useVar(containerElement);\n  var previousVnode = useVar(); // It's important that we clone the incoming vnode, because snabbdom will mutate it when we\n  // pass it to patch.\n\n  var clonedVnode = cloneNode(vnode);\n  useInitialize(function () {\n    return function () {\n      // cleanup\n      savedContainerElement.current.innerHTML = ''; // I think we want to do this\n    };\n  });\n\n  if (previousVnode.current) {\n    patch(previousVnode.current, clonedVnode);\n  } else {\n    // First patch\n    // Insert a dummy element because snabbdom replaces it (rather than inserting under)\n    var elem = document.createElement('div');\n    savedContainerElement.current.appendChild(elem);\n    patch(elem, clonedVnode);\n  }\n\n  previousVnode.current = clonedVnode;\n}\n/**\n * Note that selector is only read upon init\n */\n\nexport function renderDOMIntoSelector(vnode, containerSelector) {\n  var containerElement = useVar(function () {\n    return document.querySelector(containerSelector);\n  }); // cache\n\n  renderDOMIntoElement(vnode, containerElement.current);\n}\nexport function renderDOMAppendedToBody(vnode) {\n  var savedContainerElement = useVar();\n  useInitialize(function () {\n    var containerElement = document.createElement('div');\n    document.body.appendChild(containerElement);\n    savedContainerElement.current = containerElement;\n    return function () {\n      // cleanup\n      document.body.removeChild(containerElement);\n    };\n  });\n  renderDOMIntoElement(vnode, savedContainerElement.current);\n}","import { ExecutionContext } from 'riv-runtime';\nimport { CompiledDefinition } from \"./Compiler\";\n\nexport type StreamID = string;\nexport type FunctionID = string;\n\nexport interface ProgramNode {\n  readonly type: 'Program';\n  readonly id: string;\n  readonly name: string;\n  readonly mainDefinition: UserFunctionNode;\n}\nexport function isProgramNode(node: Node): node is ProgramNode {\n  return node.type === 'Program';\n}\n\nexport interface IdentifierNode {\n  readonly type: 'Identifier';\n  readonly name: string;\n}\nexport function isIdentifierNode(node: Node): node is IdentifierNode {\n  return node.type === 'Identifier';\n}\n\nexport interface UndefinedExpressionNode {\n  readonly type: 'UndefinedExpression';\n  readonly streamId: StreamID;\n  readonly identifier: IdentifierNode | null;\n}\nexport function isUndefinedExpressionNode(node: Node): node is UndefinedExpressionNode {\n  return node.type === 'UndefinedExpression';\n}\n\nexport interface IntegerLiteralNode {\n  readonly type: 'IntegerLiteral';\n  readonly streamId: StreamID;\n  readonly identifier: IdentifierNode | null;\n  readonly value: number;\n}\nexport function isIntegerLiteralNode(node: Node): node is IntegerLiteralNode {\n  return node.type === 'IntegerLiteral';\n}\n\nexport interface ArrayLiteralNode {\n  readonly type: 'ArrayLiteral';\n  readonly streamId: StreamID;\n  readonly identifier: IdentifierNode | null;\n  readonly items: ReadonlyArray<ExpressionNode>;\n}\nexport function isArrayLiteralNode(node: Node): node is ArrayLiteralNode {\n  return node.type === 'ArrayLiteral';\n}\n\nexport interface StreamReferenceNode {\n  readonly type: 'StreamReference';\n  readonly streamId: StreamID;\n  readonly identifier: IdentifierNode | null;\n  readonly targetStreamId: StreamID;\n}\nexport function isStreamReferenceNode(node: Node): node is StreamReferenceNode {\n  return node.type === 'StreamReference';\n}\n\nexport interface ApplicationNode {\n  readonly type: 'Application';\n  readonly streamId: StreamID, // stream of the function \"output\"\n  readonly identifier: IdentifierNode | null;\n  readonly functionId: FunctionID; // the function we are applying (calling), could be user-defined or external\n  readonly arguments: ReadonlyArray<ExpressionNode>;\n  readonly functionArguments: ReadonlyArray<UserFunctionNode>;\n}\nexport function isApplicationNode(node: Node): node is ApplicationNode {\n  return node.type === 'Application';\n}\n\nexport interface ParameterNode {\n  readonly type: 'Parameter';\n  readonly streamId: StreamID;\n  readonly identifier: IdentifierNode | null;\n}\nexport function isParameterNode(node: Node): node is ParameterNode {\n  return node.type === 'Parameter';\n}\n\nexport type ExpressionNode = UndefinedExpressionNode | IntegerLiteralNode | ArrayLiteralNode | StreamReferenceNode | ApplicationNode | ParameterNode;\nexport function isExpressionNode(node: Node): node is ExpressionNode {\n  return isUndefinedExpressionNode(node)\n    || isIntegerLiteralNode(node)\n    || isArrayLiteralNode(node)\n    || isStreamReferenceNode(node)\n    || isApplicationNode(node)\n    || isParameterNode(node);\n}\n\nexport interface FunctionSignature {\n  readonly parameters: ReadonlyArray<string>; // just the names for now\n  readonly functionParameters: ReadonlyArray<[string, FunctionSignature]>; // names and signatures\n}\n\nexport interface NativeFunctionNode {\n  readonly type: 'NativeFunction';\n  readonly functionId: FunctionID;\n  readonly identifier: IdentifierNode | null;\n  readonly signature: FunctionSignature;\n}\nexport function isNativeFunctionNode(node: Node): node is NativeFunctionNode {\n  return node.type === 'NativeFunction';\n}\n\nexport interface UserFunctionNode {\n  readonly type: 'UserFunction';\n  readonly functionId: FunctionID;\n  readonly identifier: IdentifierNode | null;\n  readonly signature: FunctionSignature;\n  readonly parameters: ReadonlyArray<ParameterNode>;\n  readonly functionParameterFunctionIds: ReadonlyArray<FunctionID>;\n  readonly expressions: ReadonlyArray<ExpressionNode>; // the \"body\" of the function\n}\nexport function isUserFunctionNode(node: Node): node is UserFunctionNode {\n  return node.type === 'UserFunction';\n}\n\nexport type FunctionNode = NativeFunctionNode | UserFunctionNode;\nexport function isFunctionNode(node: Node): node is FunctionNode {\n  return isNativeFunctionNode(node) || isUserFunctionNode(node);\n}\n\nexport type Node = ProgramNode | IdentifierNode | ExpressionNode | FunctionNode;\nexport function isNode(node: any): node is Node {\n  return isProgramNode(node) || isIdentifierNode(node) || isExpressionNode(node) || isFunctionNode(node);\n}\n\nexport function pathIsPrefix(a: Path, b: Path): boolean {\n  if (a.length > b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport type Path = ReadonlyArray<string | number>;\n\nexport type NodeEditState = {\n  readonly originalNode: Node,\n  readonly tentativeNode: Node,\n} | null;\n\nexport interface UndoStackFrame {\n  readonly program: ProgramNode;\n  readonly selectionPath: Path;\n};\n\nexport interface ClipboardStackFrame {\n  readonly mode: 'cut' | 'copy';\n  readonly streamId: StreamID;\n}\n\nexport interface State {\n  readonly program: ProgramNode;\n  readonly selectionPath: Path;\n  readonly editingSelected: NodeEditState;\n  readonly nativeFunctions: ReadonlyArray<NativeFunctionNode>;\n  readonly derivedLookups: {\n    streamIdToNode: ReadonlyMap<StreamID, ExpressionNode> | null;\n    functionIdToNode: ReadonlyMap<FunctionID, FunctionNode> | null;\n    nodeToPath: ReadonlyMap<Node, Path> | null;\n  };\n  readonly liveMain: {\n    context: ExecutionContext;\n    compiledDefinition: CompiledDefinition | null;\n    updateCompiledDefinition: (newDefinition: CompiledDefinition) => void;\n  } | null;\n  readonly undoStack: ReadonlyArray<UndoStackFrame>;\n  readonly clipboardStack: ReadonlyArray<ClipboardStackFrame>;\n}\n","const gen32 = (): string => Math.random().toString(16).substring(2, 10);\n\nexport default (): string => gen32() + gen32();\n","// TODO: We could just make this an alias for {[key: string]: V}, use plain funcs instead of methods\nexport default class Environment<V> {\n  private obj: {[key: string]: V};\n\n  constructor(outer: Environment<V> | undefined = undefined) {\n    this.obj = Object.create(outer ? outer.obj : null);\n  }\n\n  get(name: string): V | undefined {\n    return this.obj[name];\n  }\n\n  set(name: string, value: V) {\n    this.obj[name] = value;\n  }\n\n  delete(name: string): void {\n    delete this.obj[name];\n  }\n}\n","import { Path, Node, isExpressionNode, isFunctionNode, UserFunctionNode, ParameterNode, ExpressionNode, pathIsPrefix } from './State';\n\ntype TraversalVisitor = (node: Node, path: Path) => [boolean, Node];\n\ninterface TraversalOptions {\n  onlyLocal?: true; // do not traverse into contained function definitions\n  alongPath?: Path;\n}\n\n// Returns [exit, newNode]. exit indicates an early end to traversal. newNode returns replacement node, which may be the same node\n// Warning: This is a juicy-ass function that demands respect.\nfunction recursiveTraverseTree(node: Node, path: Path, options: TraversalOptions, visit: TraversalVisitor): [boolean, Node] {\n  if (options.alongPath && !pathIsPrefix(path, options.alongPath)) {\n    return [false, node];\n  }\n\n  // Recurse\n  let exited = false;\n  let newNode: Node = node;\n\n  if ((isExpressionNode(newNode) || isFunctionNode(newNode)) && newNode.identifier) {\n    const [exit, newIdentifier] = recursiveTraverseTree(newNode.identifier, path.concat(['identifier']), options, visit);\n    if (exit) exited = true;\n    if (newIdentifier !== newNode.identifier) {\n      newNode = {\n        ...newNode,\n        identifier: newIdentifier,\n      } as Node;\n    };\n  }\n\n  switch (newNode.type) {\n    case 'Program': {\n      const [exit, newMainDefinition] = recursiveTraverseTree(newNode.mainDefinition, path.concat(['mainDefinition']), options, visit);\n      if (exit) exited = true;\n      if (newMainDefinition !== newNode.mainDefinition) {\n        newNode = {\n          ...newNode,\n          mainDefinition: newMainDefinition as UserFunctionNode,\n        };\n      }\n      break;\n    }\n\n    case 'UserFunction': {\n      const newParameters: Array<ParameterNode> = [];\n      const newExpressions: Array<ExpressionNode> = [];\n      let anyNewChildren = false;\n\n      newNode.parameters.forEach((parameter, idx) => {\n        if (exited) {\n          newParameters.push(parameter);\n        } else {\n          const [exit, newParameter] = recursiveTraverseTree(parameter, path.concat(['parameters', idx]), options, visit);\n          if (exit) exited = true;\n          newParameters.push(newParameter as ParameterNode);\n          if (newParameter !== parameter) anyNewChildren = true;\n        }\n      });\n\n      newNode.expressions.forEach((expression, idx) => {\n        if (exited) {\n          newExpressions.push(expression);\n        } else {\n          const [exit, newExpression] = recursiveTraverseTree(expression, path.concat(['expressions', idx]), options, visit);\n          if (exit) exited = true;\n          newExpressions.push(newExpression as ExpressionNode);\n          if (newExpression !== expression) anyNewChildren = true;\n        }\n      });\n\n      if (anyNewChildren) {\n        newNode = {\n          ...newNode,\n          parameters: newParameters,\n          expressions: newExpressions,\n        };\n      }\n      break;\n    }\n\n    case 'Application': {\n      const newArguments: Array<ExpressionNode> = [];\n      const newFunctionArguments: Array<UserFunctionNode> = [];\n      let anyNewChildren = false;\n\n      newNode.arguments.forEach((argument, idx) => {\n        if (exited) {\n          newArguments.push(argument);\n        } else {\n          const [exit, newArgument] = recursiveTraverseTree(argument, path.concat(['arguments', idx]), options, visit);\n          if (exit) exited = true;\n          newArguments.push(newArgument as ExpressionNode);\n          if (newArgument !== argument) anyNewChildren = true;\n        }\n      });\n\n      newNode.functionArguments.forEach((functionArgument, idx) => {\n        if (exited || options.onlyLocal) {\n          newFunctionArguments.push(functionArgument);\n        } else {\n          const [exit, newFunctionArgument] = recursiveTraverseTree(functionArgument, path.concat(['functionArguments', idx]), options, visit);\n          if (exit) exited = true;\n          newFunctionArguments.push(newFunctionArgument as UserFunctionNode);\n          if (newFunctionArgument !== functionArgument) anyNewChildren = true;\n        }\n      });\n\n      if (anyNewChildren) {\n        newNode = {\n          ...newNode,\n          arguments: newArguments,\n          functionArguments: newFunctionArguments,\n        };\n      }\n      break;\n    }\n\n    case 'ArrayLiteral': {\n      let newItems: Array<ExpressionNode> = [];\n      let anyNewChildren = false;\n\n      newNode.items.forEach((item, idx) => {\n        if (exited) {\n          newItems.push(item);\n        } else {\n          const [exit, newItem] = recursiveTraverseTree(item, path.concat(['items', idx]), options, visit);\n          if (exit) exited = true;\n          newItems.push(newItem as ExpressionNode);\n          if (newItem !== item) anyNewChildren = true;\n        }\n      });\n\n      if (anyNewChildren) {\n        newNode = {\n          ...newNode,\n          items: newItems,\n        };\n      }\n      break;\n    }\n\n    case 'Identifier':\n    case 'IntegerLiteral':\n    case 'StreamReference':\n    case 'UndefinedExpression':\n    case 'Parameter':\n      // Nothing else to recurse into\n      break;\n\n    default:\n      throw new Error();\n  }\n\n  if (exited) {\n    return [exited, newNode];\n  }\n\n  return visit(newNode, path);\n}\n\n// Post-order traversal. Avoids returning new node unless something has changed.\nexport function traverseTree(node: Node, options: TraversalOptions, visit: TraversalVisitor): Node {\n  const [, newNode] = recursiveTraverseTree(node, [], options, visit);\n  return newNode;\n}\n","import { StreamID, FunctionID, ExpressionNode, FunctionNode, UserFunctionNode, isUserFunctionNode, isExpressionNode, isParameterNode } from './State';\nimport Environment from './Environment';\nimport { traverseTree } from './Traversal';\n\n/*\nSay we have the expression \"display(add(time(), 10))\". The call to display is an expression node, with streamId 'S1'. The call to add is an expression node with streamId 'S2'. The call to time is an expression node with streamId 'S3'. The literal 10 is a node with streamId 'S4'.\n\nconst compiledDefinition = {\n  parameterStreams: [],\n  literalStreamValues: [\n    ['S4', 10],\n  ],\n  applications: [\n    ['S3', 'time', [], []],\n    ['S2', 'add', ['S3', 'S4'], []],\n    ['S1', 'display', ['S2'], []],\n  ],\n  containedDefinitions: [],\n  yieldStream: null,\n};\n*/\n\nexport interface CompiledDefinition {\n  parameterStreams: Array<StreamID>;\n  // TODO: support function-parameters\n  literalStreamValues: Array<[StreamID, any]>;\n  applications: Array<[StreamID, FunctionID, Array<StreamID>, Array<FunctionID>]>;\n  containedDefinitions: Array<[FunctionID, CompiledDefinition]>;\n  yieldStream: StreamID | null;\n  externalReferencedStreamIds: Set<StreamID>;\n}\n\nexport class CompilationError extends Error {\n};\n\ninterface TraversalContext {\n  streamEnvironment: Environment<ExpressionNode>;\n  functionEnvironment: Environment<FunctionNode>;\n  localStreamIds: Set<StreamID>;\n  localFunctionIds: Set<FunctionID>;\n  temporaryMarkedStreamIds: Set<StreamID>;\n  permanentMarkedStreamIds: Set<StreamID>;\n  compiledDefinition: CompiledDefinition;\n}\n\nfunction traverseFromExpression(expression: ExpressionNode, context: TraversalContext): void {\n  const {streamEnvironment, functionEnvironment, localStreamIds, temporaryMarkedStreamIds, permanentMarkedStreamIds, compiledDefinition} = context;\n\n  if (permanentMarkedStreamIds.has(expression.streamId)) {\n    return;\n  }\n\n  if (temporaryMarkedStreamIds.has(expression.streamId)) {\n    throw new CompilationError('graph cycle');\n  }\n\n\n  switch (expression.type) {\n    case 'Parameter':\n      // Nothing to be done\n      break;\n\n      case 'UndefinedExpression':\n      compiledDefinition.literalStreamValues.push([expression.streamId, undefined]);\n      break;\n\n    case 'IntegerLiteral':\n      compiledDefinition.literalStreamValues.push([expression.streamId, expression.value]);\n      break;\n\n    case 'ArrayLiteral':\n      temporaryMarkedStreamIds.add(expression.streamId);\n      for (const item of expression.items) {\n        traverseFromExpression(item, context);\n      }\n      temporaryMarkedStreamIds.delete(expression.streamId);\n\n      // An array literal is handled as a function application, where the function is Array.of() which builds an array from its arguments.\n      compiledDefinition.applications.push([expression.streamId, 'Array_of', expression.items.map(item => item.streamId), []]);\n      break;\n\n    case 'StreamReference':\n      if (localStreamIds.has(expression.targetStreamId)) {\n        const targetExpressionNode = streamEnvironment.get(expression.targetStreamId);\n        if (!targetExpressionNode) {\n          throw Error();\n        }\n\n        temporaryMarkedStreamIds.add(expression.streamId);\n        traverseFromExpression(targetExpressionNode, context);\n        temporaryMarkedStreamIds.delete(expression.streamId);\n      } else {\n        if (streamEnvironment.get(expression.targetStreamId) === undefined) {\n          throw new Error();\n        }\n        compiledDefinition.externalReferencedStreamIds.add(expression.targetStreamId);\n      }\n\n      // For now, we do an inefficient copy rather than being smart\n      compiledDefinition.applications.push([expression.streamId, 'id', [expression.targetStreamId], []]);\n      break;\n\n    case 'Application':\n      const functionNode = functionEnvironment.get(expression.functionId);\n      if (!functionNode) {\n        throw Error();\n      }\n\n      temporaryMarkedStreamIds.add(expression.streamId);\n\n      for (const argument of expression.arguments) {\n        traverseFromExpression(argument, context);\n      }\n\n      for (const functionArgument of expression.functionArguments) {\n        const compiledContainedDef = compileUserDefinition(functionArgument, streamEnvironment, functionEnvironment);\n\n        compiledContainedDef.externalReferencedStreamIds.forEach((sid) => {\n          compiledDefinition.externalReferencedStreamIds.add(sid);\n        });\n\n        // An application needs to traverse from its function-arguments out to any streams (in this exact scope)\n        // that it refers to (outer-scope references), because these are dependencies. So this would be an invalid cycle:\n        // x = map(v => x, [1,2,3])\n        compiledContainedDef.externalReferencedStreamIds.forEach((sid) => {\n          if (localStreamIds.has(sid)) {\n            const depLocalExprNode = streamEnvironment.get(sid);\n            if (depLocalExprNode === undefined) {\n              throw new Error();\n            }\n            traverseFromExpression(depLocalExprNode, context);\n          }\n        });\n\n        compiledDefinition.containedDefinitions.push([functionArgument.functionId, compiledContainedDef]);\n      }\n\n      temporaryMarkedStreamIds.delete(expression.streamId);\n\n      compiledDefinition.applications.push([expression.streamId, functionNode.functionId, expression.arguments.map(item => item.streamId), expression.functionArguments.map(item => item.functionId)]);\n      break;\n\n    default:\n      throw new Error();\n  }\n\n  permanentMarkedStreamIds.add(expression.streamId);\n}\n\nfunction compileUserDefinition(definition: UserFunctionNode, outerStreamEnvironment: Environment<ExpressionNode>, outerFunctionEnvironment: Environment<FunctionNode>): CompiledDefinition {\n  const streamEnvironment: Environment<ExpressionNode> = new Environment(outerStreamEnvironment);\n  const functionEnvironment: Environment<FunctionNode> = new Environment(outerFunctionEnvironment);\n  const localStreamIds: Set<StreamID> = new Set();\n  const localFunctionIds: Set<FunctionID> = new Set();\n\n  // Traverse (just local scope) to find defined streams/functions\n  traverseTree(definition, {onlyLocal: true}, (node, ) => {\n    if (isExpressionNode(node) || isParameterNode(node)) {\n      if (streamEnvironment.get(node.streamId) !== undefined) {\n        throw new Error('must be unique');\n      }\n      streamEnvironment.set(node.streamId, node);\n      localStreamIds.add(node.streamId);\n    }\n\n    if (isUserFunctionNode(node)) {\n      if (functionEnvironment.get(node.functionId) !== undefined) {\n        throw new Error('must be unique');\n      }\n      functionEnvironment.set(node.functionId, node);\n      localFunctionIds.add(node.functionId);\n    }\n\n    return [false, node];\n  });\n\n  // Using terminology from https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n  const temporaryMarkedStreamIds: Set<StreamID> = new Set();\n  const permanentMarkedStreamIds: Set<StreamID> = new Set();\n  const compiledDefinition: CompiledDefinition = {\n    parameterStreams: definition.parameters.map(param => param.streamId),\n    literalStreamValues: [],\n    applications: [],\n    containedDefinitions: [],\n    yieldStream: null,\n    externalReferencedStreamIds: new Set(),\n  };\n\n  for (const expression of definition.expressions) {\n    traverseFromExpression(expression, {\n      streamEnvironment,\n      functionEnvironment,\n      localStreamIds,\n      localFunctionIds,\n      temporaryMarkedStreamIds,\n      permanentMarkedStreamIds,\n      compiledDefinition,\n    });\n    compiledDefinition.yieldStream = expression.streamId; // yield the last expression\n  }\n\n  return compiledDefinition;\n}\n\nexport function compileGlobalUserDefinition(definition: UserFunctionNode, globalFunctionEnvironment: Environment<FunctionNode>): CompiledDefinition {\n  const streamEnvironment: Environment<ExpressionNode> = new Environment();\n  const functionEnvironment: Environment<FunctionNode> = new Environment(globalFunctionEnvironment);\n\n  return compileUserDefinition(definition, streamEnvironment, functionEnvironment);\n}\n","import { FunctionSignature } from './State';\nconst { showString, animationTime, mouseDown, changeCount, streamMap, audioDriver, random, mouseClickEvts, redCircle, mousePosition, latestValue } = require('riv-demo-lib');\n\ninterface Vec2d {\n  x: number;\n  y: number;\n}\n\nfunction vec2dlen(v: Vec2d) {\n  return Math.sqrt(v.x*v.x + v.y*v.y);\n}\n\nfunction vec2sqgrid(count: number, size: number) {\n  const spacing = size / count;\n  const vecs: Array<Vec2d> = [];\n  for (let y = 0; y < count; y++) {\n    for (let x = 0; x < count; x++) {\n      vecs.push({\n        x: x*spacing,\n        y: y*spacing,\n      });\n    }\n  }\n\n  return vecs;\n}\n\nconst nativeFunctions: Array<[string, string, Array<string>, Array<[string, FunctionSignature]>, Function]> = [\n  ['add', 'add', ['_a', '_b'], [], (a: number, b: number) => a + b],\n  ['sub', 'subtract', ['_a', '_b'], [], (a: number, b: number) => a - b],\n  ['mult', 'multiply', ['_a', '_b'], [], (a: number, b: number) => a * b],\n  ['div', 'divide', ['_a', '_b'], [], (a: number, b: number) => a / b],\n  ['showString', 'show value', ['_v'], [], showString],\n  ['animationTime', 'animation time', [], [], animationTime],\n  ['mouseDown', 'is mouse down', [], [], mouseDown],\n  ['changeCount', 'change count', ['_stream'], [], changeCount],\n  ['streamMap', 'map', ['_array'], [['_func', {parameters: ['value'], functionParameters: []}]], (arr: Array<any>, f: (v: any) => any) => streamMap(f, arr)],\n  ['ifte', 'if', ['cond', 'then', 'else'], [], (cond: any, _then: any, _else: any) => (cond ? _then : _else)],\n  ['audioDriver', 'play computed audio', [], [['_func', {parameters: ['audio time', 'next frame', 'sample rate'], functionParameters: []}]], audioDriver],\n  ['cos', 'cosine', ['_v'], [], Math.cos],\n  ['random', 'random', ['repick'], [], random],\n  ['mouseClickEvts', 'mouse click', [], [], mouseClickEvts],\n  ['redCircle', 'draw red circle', ['position', 'radius'], [], redCircle],\n  ['mousePosition', 'mouse position', [], [], mousePosition],\n  ['latestValue', 'latest event value', ['event stream', 'initial value'], [], latestValue],\n  ['vec2zero', 'zero 2d vector', [], [], () => ({x: 0, y: 0})],\n  ['vec2add', 'add 2d vectors', ['_a', '_b'], [], (a: Vec2d, b: Vec2d) => ({x: a.x+b.x, y: a.y+b.y})],\n  ['vec2sub', 'subtract 2d vectors', ['_a', '_b'], [], (a: Vec2d, b: Vec2d) => ({x: a.x-b.x, y: a.y-b.y})],\n  ['vec2len', 'length of 2d vector', ['_v'], [], vec2dlen],\n  ['vec2sqgrid', 'square grid of 2d vectors', ['count', 'size'], [], vec2sqgrid],\n];\n\nexport default nativeFunctions;\n","import { State, Path, StreamID, FunctionID, Node, ExpressionNode, isExpressionNode, IdentifierNode, ArrayLiteralNode, isArrayLiteralNode, FunctionNode, isApplicationNode, UserFunctionNode, isUserFunctionNode, ProgramNode, NodeEditState, UndefinedExpressionNode, isIdentifierNode, isParameterNode, pathIsPrefix } from './State';\nimport genuid from './uid';\nimport { compileGlobalUserDefinition, CompilationError, CompiledDefinition } from './Compiler';\nimport { createNullaryVoidRootExecutionContext, beginBatch, endBatch } from 'riv-runtime';\nimport { createLiveFunction } from './LiveFunction';\nimport Environment from './Environment';\nimport { traverseTree } from './Traversal';\nimport globalNativeFunctions from './globalNatives';\n\nconst REALIZE_TENTATIVE_EXPRESSION_EDITS = false;\nconst REALIZE_TENTATIVE_IDENTIFIER_EDITS = true;\n\n// We don't make a discriminated union of specific actions, but maybe we could\ninterface Action {\n  type: string;\n  char?: string;\n  newNode?: Node;\n  newPath?: Path;\n  newName?: string;\n  program?: ProgramNode;\n}\n\ninterface HandlerArgs {\n  node: Node,\n  subpath: Path,\n  editingSelected: NodeEditState,\n  action: Action;\n}\ntype HandlerResult = (undefined | [Node, Path, NodeEditState]);\ntype Handler = [string, string[], (args: HandlerArgs) => HandlerResult];\n\n// TODO: If we want to include other classes in the lists, generate an expansion over the closure\n// TODO: Instead of this, we could have handlers provide predicate functions, and use isExpressionNode, etc.\nconst SCHEMA_CLASSES: {[nodeType: string]: string[]} = {\n  Expression: ['UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference', 'Application', 'Parameter'],\n  Any: ['Program', 'Identifier', 'UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference', 'Application', 'NativeFunction', 'UserFunction'],\n}\n\nexport function nodeFromPath(root: Node, path: Path): Node {\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n  }\n  return cur;\n}\n\nfunction nodeSplitPath(node: Node, root: Node, path: Path): [Path, Path] {\n  let cur: any = root;\n  let idx = 0;\n  for (const seg of path) {\n    if (node === cur) {\n      return [path.slice(0, idx), path.slice(idx)];\n    }\n    cur = cur[seg];\n    idx++;\n  }\n\n  if (node === cur) {\n    return [path.slice(0, idx), path.slice(idx)];\n  } else {\n    throw new Error('node was not in path');\n  }\n}\n\nfunction addUserFunctionLocalEnvironment(func: UserFunctionNode, namedStreams: Array<[string, ExpressionNode]>, namedFunctions: Array<[string, FunctionNode]>) {\n  traverseTree(func, {onlyLocal: true}, (node, path) => {\n    if (isExpressionNode(node) && node.identifier) {\n      namedStreams.push([node.identifier.name, node]);\n    }\n    if (isUserFunctionNode(node) && node.identifier) {\n      namedFunctions.push([node.identifier.name, node]);\n    }\n    return [false, node];\n  });\n}\n\nfunction addEnvironmentAlongPath(root: Node, path: Path, namedStreams: Array<[string, ExpressionNode]>, namedFunctions: Array<[string, FunctionNode]>) {\n  let cur: Node = root;\n  for (const seg of path) {\n    if (cur.type === 'UserFunction') {\n      addUserFunctionLocalEnvironment(cur, namedStreams, namedFunctions);\n    }\n    cur = (cur as any)[seg];\n  }\n}\n\nexport function environmentForSelectedNode(state: State) {\n  const namedStreams: Array<[string, ExpressionNode]> = [];\n  const namedFunctions: Array<[string, FunctionNode]> = [];\n\n  for (const extFunc of state.nativeFunctions) {\n    if (extFunc.identifier) {\n      namedFunctions.push([extFunc.identifier.name, extFunc]);\n    }\n  }\n\n  addEnvironmentAlongPath(state.program, state.selectionPath, namedStreams, namedFunctions);\n\n  return {\n    namedStreams,\n    namedFunctions,\n  }\n}\n\nconst equiv = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);\n\nfunction deleteDefinitionExpression(node: UserFunctionNode, removeIdx: number): [UserFunctionNode, Path, NodeEditState] {\n  // TODO: Handle case where we delete all expressions\n  if (typeof(removeIdx) !== 'number') {\n    throw new Error();\n  }\n  const newNode = {\n    ...node,\n    expressions: [\n      ...node.expressions.slice(0, removeIdx),\n      ...node.expressions.slice(removeIdx+1),\n    ],\n  };\n\n  if (newNode.expressions.length) {\n    let newIdx = removeIdx-1;\n    newIdx = Math.max(newIdx, 0);\n    newIdx = Math.min(newIdx, node.expressions.length-1);\n    return [newNode, ['expressions', newIdx], null];\n  } else {\n    // We've deleted all expressions, so make a single empty one.\n    const n: Node = {\n      type: 'UndefinedExpression',\n      streamId: genuid(),\n      identifier: null,\n    };\n    newNode.expressions.push(n);\n    return [newNode, ['expressions', 0], {originalNode: n, tentativeNode: n}];\n  }\n}\n\nfunction endEdit({node, subpath, editingSelected}: HandlerArgs, confirm: boolean): HandlerResult {\n  if (!editingSelected) {\n    throw new Error(); // sanity check\n  }\n\n  if (isIdentifierNode(node)) {\n    // Ignore this so that it gets handled by its parent\n    return;\n  }\n\n  if (subpath.length !== 0) {\n    if (!isExpressionNode(node) || !equiv(subpath, ['identifier'])) {\n      throw new Error(); // sanity check\n    }\n\n    // Ending an edit on the identifier that is the child of this expression\n    if (!node.identifier) {\n      throw new Error();\n    }\n\n    let newIdName;\n    if (confirm) {\n      newIdName = node.identifier.name.trim();\n    } else {\n      newIdName = (editingSelected.originalNode as IdentifierNode).name;\n    }\n\n    let newIdNode: IdentifierNode | null = newIdName ? {\n      type: 'Identifier',\n      name: newIdName,\n    } : null;\n\n    return [{\n      ...node,\n      identifier: newIdNode,\n    }, [], null];\n  }\n\n  const newNode = confirm ? editingSelected.tentativeNode : editingSelected.originalNode;\n\n  let newSubpath: Path = subpath;\n  let newEditingSelected = null;\n  if (confirm) {\n    const hit = firstUndefinedNode(newNode);\n    if (hit) {\n      const [hitNode, hitPath] = hit;\n      if (hitNode !== newNode) { // need to check this otherwise we can't confirm edit of undefined node\n        newSubpath = hitPath;\n        newEditingSelected = {originalNode: hitNode, tentativeNode: hitNode};\n      }\n    }\n  }\n\n  return [newNode, newSubpath, newEditingSelected];\n}\n\nfunction firstUndefinedNode(node: Node, after: Path | undefined = undefined): [Node, Path] | undefined {\n  let passed = false; // have we passed the \"after\" path?\n  let result: [Node, Path] | undefined;\n\n  traverseTree(node, {}, (node, path) => {\n    if (after && pathIsPrefix(after, path)) {\n      passed = true;\n    }\n\n    if (node.type === 'UndefinedExpression') {\n      if (passed || !after) {\n        result = [node, path];\n        return [true, node];\n      }\n    }\n    return [false, node];\n  });\n\n  return result;\n}\n\nconst HANDLERS: Handler[] = [\n  ['Program', ['SET_PROGRAM_NAME'], ({node, subpath, editingSelected, action}) => {\n    return [{\n      ...node,\n      name: action.newName || '',\n    }, subpath, editingSelected];\n  }],\n\n  ['UserFunction', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n\n    // NOTE: This assumes that selection is on/in one of the expressions\n    const newExpressionIdx = () => {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      let newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n      newIdx = Math.max(newIdx, 0);\n      newIdx = Math.min(newIdx, node.expressions.length-1);\n      return newIdx;\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      return [node, ['expressions', newExpressionIdx()], null];\n    }\n  }],\n\n  ['UserFunction', ['DELETE'], ({node, subpath}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      return deleteDefinitionExpression(node, removeIdx);\n    }\n  }],\n\n  ['UserFunction', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      return [node, ['expressions', 0], null];\n    }\n  }],\n\n  ['Any', ['SET_NODE'], ({action}) => {\n    return [action.newNode!, [], null];\n  }],\n\n  ['Any', ['TOGGLE_EDIT'], (args) => {\n    const {node, subpath, editingSelected} = args;\n\n    if (editingSelected) {\n      return endEdit(args, true);\n    } else {\n      if (subpath.length !== 0) {\n        throw new Error();\n      }\n\n      switch (node.type) {\n        case 'IntegerLiteral':\n        case 'UndefinedExpression':\n        case 'StreamReference':\n        case 'Application':\n          return [node, subpath, {originalNode: node, tentativeNode: node}];\n\n        case 'ArrayLiteral':\n          // Can't directly edit\n          break;\n\n        default:\n          throw new Error();\n      }\n    }\n  }],\n\n  ['Any', ['ABORT_EDIT'], (args) => {\n    const {editingSelected} = args;\n\n    if (editingSelected) {\n      return endEdit(args, false);\n    }\n  }],\n\n  ['Any', ['CONFIRM_EDIT'], (args) => {\n    const {editingSelected} = args;\n\n    if (editingSelected) {\n      return endEdit(args, true);\n    }\n  }],\n\n  ['Expression', ['BEGIN_IDENTIFIER_EDIT'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (equiv(subpath, [])) {\n      const idNode = node.identifier || {\n        type: 'Identifier',\n        name: '',\n      };\n\n      return [{\n        ...node,\n        identifier: idNode,\n      }, ['identifier'], {originalNode: idNode, tentativeNode: idNode}];\n    }\n  }],\n\n  ['Expression', ['BEGIN_OVERWRITE_EDIT'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    const newNode: Node = {\n      type: 'UndefinedExpression',\n      streamId: node.streamId,\n      identifier: node.identifier,\n    };\n    return [node, subpath, {originalNode: node, tentativeNode: newNode}];\n  }],\n\n  ['Any', ['UPDATE_EDITING_TENTATIVE_NODE'], ({node, subpath, action, editingSelected}) => {\n    if (!action.newNode) {\n      throw new Error();\n    }\n    if (!editingSelected) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      let newNode: Node;\n      if (isIdentifierNode(node)) {\n        newNode = REALIZE_TENTATIVE_IDENTIFIER_EDITS ? action.newNode : node;\n      } else if (isExpressionNode(node)) {\n        newNode = REALIZE_TENTATIVE_EXPRESSION_EDITS ? action.newNode : node;\n      } else {\n        throw new Error();\n      }\n      return [newNode, subpath, {...editingSelected, tentativeNode: action.newNode}];\n    }\n  }],\n\n  ['UserFunction', ['EDIT_AFTER'], ({node, subpath}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length >= 2) && (subpath[0] === 'expressions')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const insertingExprNode: UndefinedExpressionNode = {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: null,\n      };\n      const newNode: UserFunctionNode = {\n        ...node,\n        expressions: [\n          ...node.expressions.slice(0, afterIdx+1),\n          insertingExprNode,\n          ...node.expressions.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['expressions', afterIdx+1], {originalNode: insertingExprNode, tentativeNode: insertingExprNode}];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know array is displayed vertically for now\n  ['ArrayLiteral', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath}) => {\n    if (subpath.length === 2) {\n      if ((subpath[0] !== 'items') || (typeof(subpath[1]) !== 'number')) {\n        throw Error();\n      }\n      return [node, [], null];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_RIGHT to act as ZOOM_IN here because we know it will be in a vertical-list container\n  ['ArrayLiteral', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      // We do a special thing here: If the array is empty, we create a single undefined item.\n      // This gives us a way to add a new element to an empty array.\n      if (node.items.length === 0) {\n        const newExprNode: UndefinedExpressionNode = {\n          type: 'UndefinedExpression',\n          streamId: genuid(),\n          identifier: null,\n        };\n        return [{\n          ...node,\n          items: [newExprNode],\n        }, ['items', 0], {originalNode: newExprNode, tentativeNode: newExprNode}];\n      } else {\n        return [node, ['items', 0], null];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx < 0) || (newIdx >= node.items.length)) {\n        return [node, [], null];\n      } else {\n        return [node, ['items', newIdx], null];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['EDIT_AFTER'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const insertingExprNode: UndefinedExpressionNode = {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: null,\n      };\n      const newNode: ArrayLiteralNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, afterIdx+1),\n          insertingExprNode,\n          ...node.items.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['items', afterIdx+1], {originalNode: insertingExprNode, tentativeNode: insertingExprNode}];\n    }\n  }],\n\n  ['ArrayLiteral', ['DELETE'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if (node.items.length === 0) {\n        throw new Error();\n      }\n\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, removeIdx),\n          ...node.items.slice(removeIdx+1),\n        ],\n      };\n\n      if (newNode.items.length > 0) {\n        let newIdx = removeIdx-1;\n        newIdx = Math.max(newIdx, 0);\n        newIdx = Math.min(newIdx, node.items.length-1);\n        return [newNode, ['items', newIdx], null];\n      } else {\n        return [newNode, [], null];\n      }\n    }\n  }],\n\n  ['Expression', ['CREATE_ARRAY'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n\n    if (subpath.length === 0) {\n      const newExprNode: UndefinedExpressionNode = {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: null,\n      };\n    return [{\n        type: 'ArrayLiteral',\n        streamId: node.streamId,\n        identifier: node.identifier,\n        items: [newExprNode],\n      }, ['items', 0], {originalNode: newExprNode, tentativeNode: newExprNode}];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know arguments are displayed vertically for now\n  ['UserFunction', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath}) => {\n    if (!isUserFunctionNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if ((subpath[0] === 'expressions') && (typeof(subpath[1]) === 'number')) {\n        return [node, [], null];\n      } else {\n        throw new Error();\n      }\n    }\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know arguments are displayed vertically for now\n  ['Application', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if ((subpath[0] === 'arguments') && (typeof(subpath[1]) === 'number')) {\n        return [node, [], null];\n      } else if ((subpath[0] === 'functionArguments') && (typeof(subpath[1]) === 'number')) {\n        return [node, [], null];\n      } else {\n        throw new Error();\n      }\n    }\n  }],\n\n  // NOTE: We only allow MOVE_RIGHT to act as ZOOM_IN here because we know arguments are displayed vertically for now\n  ['Application', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      if (node.arguments.length > 0) {\n        return [node, ['arguments', 0], null];\n      } else if (node.functionArguments.length > 0) {\n        return [node, ['functionArguments', 0], null];\n      }\n    }\n  }],\n\n  ['Application', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'arguments')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx >= node.arguments.length) && node.functionArguments.length) {\n        return [node, ['functionArguments', 0], null];\n      } else if ((newIdx < 0) || (newIdx >= node.arguments.length)) {\n        return [node, [], null];\n      } else {\n        return [node, ['arguments', newIdx], null];\n      }\n    } else if ((subpath.length === 2) && (subpath[0] === 'functionArguments')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx < 0) && node.arguments.length) {\n        return [node, ['arguments', node.arguments.length-1], null];\n      } else if ((newIdx < 0) || (newIdx >= node.arguments.length)) {\n        return [node, [], null];\n      } else {\n        return [node, ['functionArguments', newIdx], null];\n      }\n    }\n  }],\n\n  ['Application', ['DELETE'], ({node, subpath, action}) => {\n    if (!isApplicationNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'arguments')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n\n      const newArguments = node.arguments.slice();\n      newArguments[idx] = {\n        type: 'UndefinedExpression',\n        streamId: node.arguments[idx].streamId,\n        identifier: node.arguments[idx].identifier,\n      };\n\n      return [{\n        ...node,\n        arguments: newArguments,\n      }, ['arguments', idx], null];\n    }\n  }],\n];\n\nfunction applyActionToProgram(program: ProgramNode, selectionPath: Path, editingSelected: NodeEditState, action: Action): [ProgramNode, Path, NodeEditState] {\n  let handled = false;\n  let newSelectionPath: Path = selectionPath;\n  let newEditingSelected: NodeEditState = editingSelected;\n\n  let newProgram = traverseTree(program, {alongPath: selectionPath}, (node, path) => {\n    for (const [nt, acts, hfunc] of HANDLERS) {\n      const matchingTypes = SCHEMA_CLASSES[nt] ? SCHEMA_CLASSES[nt] : [nt];\n      if (matchingTypes.includes(node.type) && acts.includes(action.type)) {\n        const [pathBefore, pathAfter] = nodeSplitPath(node, program, selectionPath);\n        const handlerResult = hfunc({\n          node,\n          subpath: pathAfter,\n          editingSelected,\n          action,\n        });\n        if (handlerResult) {\n          // console.log('action handled, with result', handlerResult);\n          handled = true;\n          const [handlerNewNode, handlerNewSubpath, handlerNewEditingSelected] = handlerResult;\n\n          newSelectionPath = pathBefore.concat(handlerNewSubpath);\n          newEditingSelected = handlerNewEditingSelected;\n          return [true, handlerNewNode];\n        }\n      }\n    }\n\n    return [false, node];\n  });\n\n  if (newProgram.type !== 'Program') {\n    throw new Error(); // sanity check\n  }\n\n  if (!handled && ((newProgram !== program) || (newSelectionPath !== selectionPath) || (newEditingSelected !== editingSelected))) {\n    throw new Error(); // sanity check\n  }\n\n  return [newProgram, newSelectionPath, newEditingSelected];\n}\n\nfunction cutExpressionNode(program: ProgramNode, selectionPath: Path): [ProgramNode, Path] {\n  let cutNode: ExpressionNode | undefined;\n  let holeNode: ExpressionNode | undefined; // the \"hole\" after we remove\n\n  let newProgram = traverseTree(program, {alongPath: selectionPath}, (node, path) => {\n    if (equiv(path, selectionPath)) {\n      // We are at the node to be cut\n      if (!isExpressionNode(node)) {\n        throw new Error();\n      }\n      if (cutNode) {\n        throw new Error(); // sanity check\n      }\n\n      cutNode = node;\n\n      holeNode = {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: null,\n      };\n\n      return [false, holeNode];\n    } else if (isUserFunctionNode(node)) {\n      if (cutNode) {\n        // Move the node to the top level of this function definition\n        const selectionPathAfter = selectionPath.slice(path.length);\n        if ((selectionPathAfter.length < 2) || (selectionPathAfter[0] !== 'expressions')) {\n          throw new Error();\n        }\n        const idx = selectionPathAfter[1];\n        if (typeof(idx) !== 'number') {\n          throw new Error();\n        }\n\n        const newNode = {\n          ...node,\n          expressions: [\n            ...node.expressions.slice(0, idx),\n            cutNode,\n            ...node.expressions.slice(idx),\n          ],\n        };\n        cutNode = undefined;\n\n        return [false, newNode];\n      }\n    }\n\n    return [false, node];\n  });\n\n  if (newProgram.type !== 'Program') {\n    throw new Error(); // sanity check\n  }\n\n  if (!holeNode) {\n    throw new Error();\n  }\n\n  const nodeToPath = computeNodeToPathMap(newProgram);\n  const newSelectionPath = nodeToPath.get(holeNode);\n  if (!newSelectionPath) {\n    throw new Error();\n  }\n\n  return [newProgram, newSelectionPath];\n}\n\nfunction pasteExpressionNode(pasteNode: ExpressionNode, pasteStreamId: StreamID, program: ProgramNode, selectionPath: Path): [ProgramNode, Path] {\n  let newProgram = traverseTree(program, {}, (node, path) => {\n    if (equiv(path, selectionPath)) {\n      // We are at the node to be pasted over\n      if (!isExpressionNode(node)) {\n        throw new Error();\n      }\n\n      return [false, pasteNode];\n    } else if (isUserFunctionNode(node)) {\n      // NOTE: We assume that the node must be at the top level of a function definition.\n      let removeIdx;\n      node.expressions.forEach((expr, idx) => {\n        if (expr.streamId === pasteStreamId) {\n          // This is the node to remove\n          removeIdx = idx;\n        }\n      });\n\n      if (removeIdx !== undefined) {\n        const [newNode, , ] = deleteDefinitionExpression(node, removeIdx);\n        return [false, newNode];\n      }\n    }\n\n    return [false, node];\n  });\n\n  if (newProgram.type !== 'Program') {\n    throw new Error(); // sanity check\n  }\n\n  const nodeToPath = computeNodeToPathMap(newProgram);\n  const newSelectionPath = nodeToPath.get(pasteNode);\n  if (!newSelectionPath) {\n    throw new Error();\n  }\n\n  return [newProgram, newSelectionPath];\n}\n\nfunction addStateIdLookups(state: State): State {\n  const streamIdToNode: Map<StreamID, ExpressionNode> = new Map();\n  const functionIdToNode: Map<FunctionID, FunctionNode> = new Map();\n\n  for (const extFunc of state.nativeFunctions) {\n    functionIdToNode.set(extFunc.functionId, extFunc);\n  }\n\n  traverseTree(state.program, {}, (node, ) => {\n    if (isExpressionNode(node) || isParameterNode(node)) {\n      if (streamIdToNode.has(node.streamId)) {\n        throw new Error('stream ids must be unique');\n      }\n      streamIdToNode.set(node.streamId, node);\n    }\n\n    if (isUserFunctionNode(node)) {\n      if (functionIdToNode.has(node.functionId)) {\n        throw new Error('funciton ids must be unique');\n      }\n      functionIdToNode.set(node.functionId, node);\n    }\n\n    return [false, node];\n  });\n\n  return {\n    ...state,\n    derivedLookups: {\n      streamIdToNode,\n      functionIdToNode,\n      nodeToPath: null,\n    },\n  };\n}\n\nfunction computeNodeToPathMap(program: ProgramNode): Map<Node, Path> {\n  const nodeToPath: Map<Node, Path> = new Map();\n\n  traverseTree(program, {}, (node, path) => {\n    nodeToPath.set(node, path);\n    return [false, node];\n  });\n\n  return nodeToPath;\n}\n\nfunction addStatePathLookup(state: State): State {\n  return {\n    ...state,\n    derivedLookups: {\n      ...state.derivedLookups,\n      nodeToPath: computeNodeToPathMap(state.program),\n    },\n  };\n}\n\nfunction undefineDanglingStreamRefs(state: State): State {\n  const newProgram = traverseTree(state.program, {}, (node, ) => {\n    if (node.type === 'StreamReference') {\n      return [false, state.derivedLookups.streamIdToNode!.has(node.targetStreamId) ? node : {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: node.identifier,\n      }];\n    } else {\n      return [false, node];\n    }\n  });\n\n  return (newProgram === state.program) ? state : {\n    ...state,\n    program: newProgram as ProgramNode,\n  }\n}\n\nfunction addStateCompiled(oldState: State | undefined, newState: State): State {\n  // We initialize with an \"empty\" definition, which we fall back on if compilation fails\n  let newCompiledDefinition: CompiledDefinition = {\n    parameterStreams: [],\n    literalStreamValues: [],\n    applications: [],\n    containedDefinitions: [],\n    yieldStream: null,\n    externalReferencedStreamIds: new Set(),\n  };\n\n  try {\n    // NOTE: We could avoid repeating this work, but this is sort of temporary anyways\n    const globalFunctionEnvironment: Environment<FunctionNode> = new Environment();\n    for (const nf of newState.nativeFunctions) {\n      globalFunctionEnvironment.set(nf.functionId, nf);\n    }\n\n    newCompiledDefinition = compileGlobalUserDefinition(newState.program.mainDefinition, globalFunctionEnvironment);\n    // console.log('compiled to', newCompiledDefinition);\n  } catch (e) {\n    if (e instanceof CompilationError) {\n      console.log('COMPILATION ERROR', e.message);\n    } else {\n      throw e;\n    }\n  }\n\n  let newLiveMain;\n\n  if (oldState) {\n    const { context, updateCompiledDefinition } = oldState.liveMain!;\n\n    // console.log('updating compiled definition to', newCompiledDefinition);\n    beginBatch();\n    updateCompiledDefinition(newCompiledDefinition);\n    endBatch();\n\n    newLiveMain = {\n      context,\n      updateCompiledDefinition,\n      compiledDefinition: newCompiledDefinition,\n    };\n  } else {\n    // There is no old state, so we need to create the long-lived stuff\n    // console.log('initializing compiled definition to', newCompiledDefinition);\n    const [liveStreamFunc, updateCompiledDefinition] = createLiveFunction(newCompiledDefinition, new Environment(), nativeFunctionEnvironment);\n    const context = createNullaryVoidRootExecutionContext(liveStreamFunc);\n\n    context.update(); // first update that generally kicks off further async updates\n\n    newLiveMain = {\n      context,\n      updateCompiledDefinition,\n      compiledDefinition: newCompiledDefinition,\n    };\n  }\n\n  return {\n    ...newState,\n    liveMain: newLiveMain,\n  };\n}\n\nfunction addDerivedState(oldState: State | undefined, newState: State): State {\n  // undefineDanglingStreamRefs needs up-to-date id lookups\n  const danglingRemovedState = undefineDanglingStreamRefs(addStateIdLookups(newState));\n\n  return addStateCompiled(oldState, addStatePathLookup(addStateIdLookups(danglingRemovedState)));\n}\n\nexport function reducer(state: State, action: Action): State {\n  // console.log('action', action);\n\n  if (action.type === 'LOAD_PROGRAM') {\n    if (!action.program) {\n      throw new Error();\n    }\n\n    // Terminate currently running main function\n    if (!state.liveMain) {\n      throw new Error();\n    }\n    state.liveMain.context.terminate();\n\n    return initialStateFromProgram(action.program);\n  }\n\n  let newProgram = state.program;\n  let newSelectionPath = state.selectionPath;\n  let newEditingSelected = state.editingSelected;\n  let newUndoStack = state.undoStack;\n  let newClipboardStack = state.clipboardStack;\n\n  // Do an implicit confirm before certain actions\n  if (['EDIT_NEXT_UNDEFINED', 'EDIT_AFTER', 'BEGIN_IDENTIFIER_EDIT'].includes(action.type)) {\n    [newProgram, newSelectionPath, newEditingSelected] = applyActionToProgram(newProgram, newSelectionPath, newEditingSelected, {type: 'CONFIRM_EDIT'});\n  }\n\n  if (action.type === 'UNDO') {\n    if (state.undoStack.length > 0) {\n      const topFrame = newUndoStack[newUndoStack.length-1];\n      newProgram = topFrame.program;\n      newSelectionPath = topFrame.selectionPath;\n      newUndoStack = newUndoStack.slice(0, newUndoStack.length-1);\n    }\n  } else if (action.type === 'CUT') {\n    const selectedNode = nodeFromPath(newProgram, newSelectionPath);\n    if (isExpressionNode(selectedNode)) {\n      newClipboardStack = newClipboardStack.concat([{\n        mode: 'cut',\n        streamId: selectedNode.streamId,\n      }]);\n      [newProgram, newSelectionPath] = cutExpressionNode(newProgram, newSelectionPath);\n    }\n  } else if (action.type === 'PASTE') {\n    const selectedNode = nodeFromPath(newProgram, newSelectionPath);\n    if ((newClipboardStack.length > 0) && isExpressionNode(selectedNode)) {\n      const topFrame = newClipboardStack[newClipboardStack.length-1];\n      newClipboardStack = newClipboardStack.slice(0, newClipboardStack.length-1);\n      const topNode = state.derivedLookups.streamIdToNode!.get(topFrame.streamId)!;\n      [newProgram, newSelectionPath] = pasteExpressionNode(topNode, topFrame.streamId, newProgram, newSelectionPath);\n    }\n  } else if (action.type === 'SET_PATH') {\n    newSelectionPath = action.newPath!;\n    const newSelectedNode = nodeFromPath(newProgram, newSelectionPath);\n    const beginEdit = (newSelectedNode.type === 'Identifier');\n    newEditingSelected = beginEdit ? {originalNode: newSelectedNode, tentativeNode: newSelectedNode} : null;\n  } else if (action.type === 'EDIT_NEXT_UNDEFINED') {\n    const hit = firstUndefinedNode(newProgram, newSelectionPath);\n    if (hit) {\n      const [hitNode, hitPath] = hit;\n      newSelectionPath = hitPath;\n      newEditingSelected = {originalNode: hitNode, tentativeNode: hitNode};\n    } else {\n      newEditingSelected = null;\n    }\n  } else {\n    [newProgram, newSelectionPath, newEditingSelected] = applyActionToProgram(newProgram, newSelectionPath, newEditingSelected, action);\n  }\n\n  if ((newProgram !== state.program) || (newSelectionPath !== state.selectionPath) || (newEditingSelected !== state.editingSelected) || (newUndoStack !== state.undoStack) || (newClipboardStack !== state.clipboardStack)) {\n    // console.log('handled! new prog', newProgram, 'new selectionPath is', newSelectionPath, 'newEditingSelected is', newEditingSelected);\n    if (newProgram !== state.program) {\n      console.log('program changed identity');\n\n      // Push the state of things _before_ this action onto the stack\n      if (action.type !== 'UNDO') {\n        newUndoStack = newUndoStack.concat([{\n          program: state.program,\n          selectionPath: state.selectionPath,\n        }]);\n      }\n    }\n\n    return addDerivedState(state, {\n      program: newProgram,\n      selectionPath: newSelectionPath,\n      editingSelected: newEditingSelected,\n      nativeFunctions: state.nativeFunctions,\n      derivedLookups: {\n        streamIdToNode: null,\n        functionIdToNode: null,\n        nodeToPath: null,\n      },\n      liveMain: null,\n      undoStack: newUndoStack,\n      clipboardStack: newClipboardStack,\n    });\n  } else {\n    // console.log('not handled');\n    return state;\n  }\n}\n\n\n\nconst nativeFunctionEnvironment: Environment<Function> = new Environment();\nnativeFunctionEnvironment.set('id', (x: any) => x);\nnativeFunctionEnvironment.set('Array_of', Array.of);\nglobalNativeFunctions.forEach(([id, , , , jsFunc]) => {\n  nativeFunctionEnvironment.set(id, jsFunc);\n});\n\nfunction initialStateFromProgram(program: ProgramNode): State {\n  return addDerivedState(undefined, {\n    program,\n    selectionPath: ['mainDefinition'],\n    editingSelected: null,\n    nativeFunctions: globalNativeFunctions.map(([id, name, paramNames, funcParams, ]) => ({\n      type: 'NativeFunction',\n      functionId: id,\n      identifier: {\n        type: 'Identifier',\n        name,\n      },\n      signature: {\n        parameters: paramNames,\n        functionParameters: funcParams,\n      },\n    })),\n    derivedLookups: {\n      streamIdToNode: null,\n      functionIdToNode: null,\n      nodeToPath: null,\n    },\n    liveMain: null,\n    undoStack: [],\n    clipboardStack: [],\n  });\n}\n\nconst mdId = genuid();\nconst INITIAL_PROGRAM: ProgramNode = {\n  type: 'Program',\n  id: genuid(),\n  name: 'my program',\n  mainDefinition: {\n    type: 'UserFunction',\n    functionId: genuid(),\n    identifier: null,\n    signature: {\n      parameters: [],\n      functionParameters: [],\n    },\n    parameters: [],\n    functionParameterFunctionIds: [],\n    expressions: [\n      {\n        type: 'Application',\n        streamId: mdId,\n        identifier: {\n          type: 'Identifier',\n          name: 'md',\n        },\n        functionId: 'mouseDown',\n        arguments: [],\n        functionArguments: [],\n      },\n      {\n        type: 'Application',\n        streamId: genuid(),\n        identifier: null,\n        functionId: 'showString',\n        arguments: [\n          {\n            type: 'Application',\n            streamId: genuid(),\n            identifier: null,\n            functionId: 'ifte',\n            arguments: [\n              {\n                type: 'StreamReference',\n                streamId: genuid(),\n                identifier: null,\n                targetStreamId: mdId,\n              },\n              {\n                type: 'IntegerLiteral',\n                streamId: genuid(),\n                identifier: null,\n                value: 10,\n              },\n              {\n                type: 'IntegerLiteral',\n                streamId: genuid(),\n                identifier: null,\n                value: 20,\n              },\n            ],\n            functionArguments: [],\n          },\n        ],\n        functionArguments: [],\n      },\n    ],\n  },\n};\n\nexport const initialState: State = initialStateFromProgram(INITIAL_PROGRAM);\n","import { ExecutionContext, useVar, useInitialize, useRequestUpdate } from 'riv-runtime';\nimport { CompiledDefinition } from './Compiler';\nimport { StreamID, FunctionID } from './State';\nimport Environment from './Environment';\n\nfunction arraysShallowEqual(a: Array<any>, b: Array<any>): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Function environments may have names added or removed, but the value for a name must never change.\n */\nexport function createLiveFunction(initialDefinition: CompiledDefinition, outerStreamEnvironment: Environment<any>, outerFunctionEnvironment: Environment<Function>): [Function, (newDefinition: CompiledDefinition) => void] {\n  interface Activation {\n    streamEnvironment: Environment<any>;\n    functionEnvironment: Environment<Function>;\n    applicationContext: Map<string, ExecutionContext>;\n    updateContainedDefinition: Map<FunctionID, (newDefinition: CompiledDefinition) => void>;\n    requestUpdate: () => void;\n  }\n\n  const activations: Set<Activation> = new Set();\n  let compiledDefinition = initialDefinition;\n\n  function streamFunc() { // NOTE: this can't be an arrow function because we use \"arguments\"\n    /* eslint-disable react-hooks/rules-of-hooks */\n    const requestUpdate = useRequestUpdate();\n\n    const activation = useVar<Activation>(() => {\n      const streamEnvironment = new Environment(outerStreamEnvironment);\n      const functionEnvironment = new Environment(outerFunctionEnvironment);\n\n      for (const [sid, value] of compiledDefinition.literalStreamValues) {\n        streamEnvironment.set(sid, value);\n      }\n\n      const applicationContext: Map<StreamID, ExecutionContext> = new Map();\n      for (const [sid, fid, ] of compiledDefinition.applications) {\n        const func = functionEnvironment.get(fid);\n        if (!func) {\n          console.log(fid);\n          throw Error();\n        }\n        applicationContext.set(sid, new ExecutionContext(func, requestUpdate));\n      }\n\n      const updateContainedDefinition: Map<FunctionID, (newDefinition: CompiledDefinition) => void> = new Map();\n      for (const [fid, def] of compiledDefinition.containedDefinitions) {\n        const [sf, updateDef] = createLiveFunction(def, streamEnvironment, functionEnvironment);\n        functionEnvironment.set(fid, sf);\n        updateContainedDefinition.set(fid, updateDef);\n      }\n\n      return {\n        streamEnvironment,\n        functionEnvironment,\n        applicationContext,\n        updateContainedDefinition,\n        requestUpdate,\n      };\n    });\n\n    useInitialize(() => {\n      activations.add(activation.current);\n      return () => {\n        activation.current.applicationContext.forEach((ctx) => {\n          ctx.terminate();\n        });\n        activations.delete(activation.current);\n      };\n    });\n\n    const {streamEnvironment: streamEnv, functionEnvironment: funcEnv, applicationContext: appCtx} = activation.current;\n\n    if (arguments.length !== compiledDefinition.parameterStreams.length) {\n      throw new Error('wrong number of arguments to live function, got ' + arguments.length + ' expected ' + compiledDefinition.parameterStreams.length);\n    }\n    let idx = 0;\n    for (const sid of compiledDefinition.parameterStreams) {\n      streamEnv.set(sid, arguments[idx]);\n      idx++;\n    }\n\n    for (const [sid, , argIds, fargIds] of compiledDefinition.applications) {\n      const argVals = [...argIds.map(sid => streamEnv.get(sid)), ...fargIds.map(fid => funcEnv.get(fid))];\n      const context = appCtx.get(sid);\n      if (!context) { throw new Error(); }\n      let appVal;\n      try {\n        appVal = context.update(...argVals);\n      } catch (e) {\n        console.log('application error');\n      }\n      streamEnv.set(sid, appVal);\n    }\n\n    if (compiledDefinition.yieldStream) {\n      return streamEnv.get(compiledDefinition.yieldStream);\n    } else {\n      return undefined;\n    }\n  };\n\n  const updateCompiledDefinition = (newDefinition: CompiledDefinition): void => {\n    if (JSON.stringify(newDefinition) === JSON.stringify(compiledDefinition)) {\n      return;\n    }\n\n    //\n    // RECONCILE LITERALS\n    //\n    const oldLiteralMap: Map<string, any> = new Map();\n    const newLiteralMap: Map<string, any> = new Map();\n\n    for (const [sid, val] of compiledDefinition.literalStreamValues) {\n      oldLiteralMap.set(sid, val);\n    }\n    for (const [sid, val] of newDefinition.literalStreamValues) {\n      newLiteralMap.set(sid, val);\n    }\n\n    for (const [sid, ] of compiledDefinition.literalStreamValues) {\n      if (!newLiteralMap.has(sid)) {\n        activations.forEach(activation => {\n          activation.streamEnvironment.delete(sid);\n        });\n      }\n    }\n\n    for (const [sid, val] of newDefinition.literalStreamValues) {\n      if (!oldLiteralMap.has(sid) || (oldLiteralMap.get(sid) !== val)) {\n        activations.forEach(activation => {\n          activation.streamEnvironment.set(sid, val);\n        });\n      }\n    }\n\n    //\n    // RECONCILE APPLICATIONS\n    //\n    const oldAppMap: Map<string, [FunctionID, Array<string>]> = new Map();\n    const newAppMap: Map<string, [FunctionID, Array<string>]> = new Map();\n\n    for (const [sid, func, args] of compiledDefinition.applications) {\n      oldAppMap.set(sid, [func, args]);\n    }\n    for (const [sid, func, args] of newDefinition.applications) {\n      newAppMap.set(sid, [func, args]);\n    }\n\n    for (const [sid, , ] of compiledDefinition.applications) {\n      if (!newAppMap.has(sid)) {\n        activations.forEach(activation => {\n          activation.applicationContext.get(sid)!.terminate();\n        });\n      }\n    }\n\n    for (const [sid, funcId, args] of newDefinition.applications) {\n      let createNew = false;\n\n      const oldApp = oldAppMap.get(sid);\n      if (oldApp) {\n        const [oldFuncId, oldArgs] = oldApp;\n\n        if ((funcId !== oldFuncId) || !arraysShallowEqual(args, oldArgs)) {\n          activations.forEach(activation => {\n            activation.applicationContext.get(sid)!.terminate();\n          });\n\n          createNew = true;\n        }\n      } else {\n        createNew = true;\n      }\n\n      if (createNew) {\n        activations.forEach(activation => {\n          const func = activation.functionEnvironment.get(funcId);\n          if (!func) {\n            throw Error();\n          }\n          activation.applicationContext.set(sid, new ExecutionContext(func, activation.requestUpdate));\n        });\n      }\n    }\n\n    //\n    // RECONCILE CONTAINED DEFINITIONS\n    //\n    const oldDefMap: Map<FunctionID, CompiledDefinition> = new Map();\n    const newDefMap: Map<FunctionID, CompiledDefinition> = new Map();\n\n    for (const [fid, def] of compiledDefinition.containedDefinitions) {\n      oldDefMap.set(fid, def);\n    }\n    for (const [fid, def] of newDefinition.containedDefinitions) {\n      newDefMap.set(fid, def);\n    }\n\n    for (const [fid, ] of compiledDefinition.containedDefinitions) {\n      if (!newDefMap.has(fid)) {\n        activations.forEach(activation => {\n          activation.functionEnvironment.delete(fid);\n          activation.updateContainedDefinition.delete(fid);\n        });\n      }\n    }\n\n    for (const [fid, def] of newDefinition.containedDefinitions) {\n      if (!oldDefMap.has(fid)) {\n        activations.forEach(activation => {\n          const [sf, updateDef] = createLiveFunction(def, activation.streamEnvironment, activation.functionEnvironment);\n          activation.functionEnvironment.set(fid, sf);\n          activation.updateContainedDefinition.set(fid, updateDef);\n        });\n      } else {\n        activations.forEach(activation => {\n          activation.updateContainedDefinition.get(fid)!(def);\n        });\n      }\n    }\n\n    //\n    // FINISH UP\n    //\n    compiledDefinition = newDefinition;\n\n    activations.forEach(activation => {\n      activation.requestUpdate();\n    });\n  };\n\n  return [streamFunc, updateCompiledDefinition];\n}\n","// slightly adapted from https://github.com/forrestthewoods/lib_fts/blob/master/code/fts_fuzzy_match.js\r\n\r\n// LICENSE\r\n//\r\n//   This software is dual-licensed to the public domain and under the following\r\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\r\n//   publish, and distribute this file as you see fit.\r\n//\r\n// VERSION\r\n//   0.1.0  (2016-03-28)  Initial release\r\n//\r\n// AUTHOR\r\n//   Forrest Smith\r\n//\r\n// CONTRIBUTORS\r\n//   Jrgen Tjern - async helper\r\n\r\n\r\n// Returns true if each character in pattern is found sequentially within str\r\nexport function fuzzy_match_simple(pattern, str) {\r\n\r\n    var patternIdx = 0;\r\n    var strIdx = 0;\r\n    var patternLength = pattern.length;\r\n    var strLength = str.length;\r\n\r\n    while (patternIdx !== patternLength && strIdx !== strLength) {\r\n        var patternChar = pattern.charAt(patternIdx).toLowerCase();\r\n        var strChar = str.charAt(strIdx).toLowerCase();\r\n        if (patternChar === strChar)\r\n            ++patternIdx;\r\n        ++strIdx;\r\n    }\r\n\r\n    return patternLength !== 0 && strLength !== 0 && patternIdx === patternLength ? true : false;\r\n}\r\n\r\n// Returns [bool, score, formattedStr]\r\n// bool: true if each character in pattern is found sequentially within str\r\n// score: integer; higher is better match. Value has no intrinsic meaning. Range varies with pattern.\r\n//        Can only compare scores with same search pattern.\r\n// formattedStr: input str with matched characters marked in <b> tags. Delete if unwanted.\r\nexport function fuzzy_match(pattern, str) {\r\n\r\n    // Score consts\r\n    var adjacency_bonus = 5;                // bonus for adjacent matches\r\n    var separator_bonus = 10;               // bonus if match occurs after a separator\r\n    var camel_bonus = 10;                   // bonus if match is uppercase and prev is lower\r\n    var leading_letter_penalty = -3;        // penalty applied for every letter in str before the first match\r\n    var max_leading_letter_penalty = -9;    // maximum penalty for leading letters\r\n    var unmatched_letter_penalty = -1;      // penalty for every letter that doesn't matter\r\n\r\n    // Loop variables\r\n    var score = 0;\r\n    var patternIdx = 0;\r\n    var patternLength = pattern.length;\r\n    var strIdx = 0;\r\n    var strLength = str.length;\r\n    var prevMatched = false;\r\n    var prevLower = false;\r\n    var prevSeparator = true;       // true so if first letter match gets separator bonus\r\n\r\n    // Use \"best\" matched letter if multiple string letters match the pattern\r\n    var bestLetter = null;\r\n    var bestLower = null;\r\n    var bestLetterIdx = null;\r\n    var bestLetterScore = 0;\r\n\r\n    var matchedIndices = [];\r\n\r\n    // Loop over strings\r\n    while (strIdx !== strLength) {\r\n        var patternChar = patternIdx !== patternLength ? pattern.charAt(patternIdx) : null;\r\n        var strChar = str.charAt(strIdx);\r\n\r\n        var patternLower = patternChar !== null ? patternChar.toLowerCase() : null;\r\n        var strLower = strChar.toLowerCase();\r\n        var strUpper = strChar.toUpperCase();\r\n\r\n        var nextMatch = patternChar && patternLower === strLower;\r\n        var rematch = bestLetter && bestLower === strLower;\r\n\r\n        var advanced = nextMatch && bestLetter;\r\n        var patternRepeat = bestLetter && patternChar && bestLower === patternLower;\r\n        if (advanced || patternRepeat) {\r\n            score += bestLetterScore;\r\n            matchedIndices.push(bestLetterIdx);\r\n            bestLetter = null;\r\n            bestLower = null;\r\n            bestLetterIdx = null;\r\n            bestLetterScore = 0;\r\n        }\r\n\r\n        if (nextMatch || rematch) {\r\n            var newScore = 0;\r\n\r\n            // Apply penalty for each letter before the first pattern match\r\n            // Note: std::max because penalties are negative values. So max is smallest penalty.\r\n            if (patternIdx === 0) {\r\n                var penalty = Math.max(strIdx * leading_letter_penalty, max_leading_letter_penalty);\r\n                score += penalty;\r\n            }\r\n\r\n            // Apply bonus for consecutive bonuses\r\n            if (prevMatched)\r\n                newScore += adjacency_bonus;\r\n\r\n            // Apply bonus for matches after a separator\r\n            if (prevSeparator)\r\n                newScore += separator_bonus;\r\n\r\n            // Apply bonus across camel case boundaries. Includes \"clever\" isLetter check.\r\n            if (prevLower && strChar === strUpper && strLower !== strUpper)\r\n                newScore += camel_bonus;\r\n\r\n            // Update patter index IFF the next pattern letter was matched\r\n            if (nextMatch)\r\n                ++patternIdx;\r\n\r\n            // Update best letter in str which may be for a \"next\" letter or a \"rematch\"\r\n            if (newScore >= bestLetterScore) {\r\n\r\n                // Apply penalty for now skipped letter\r\n                if (bestLetter !== null)\r\n                    score += unmatched_letter_penalty;\r\n\r\n                bestLetter = strChar;\r\n                bestLower = bestLetter.toLowerCase();\r\n                bestLetterIdx = strIdx;\r\n                bestLetterScore = newScore;\r\n            }\r\n\r\n            prevMatched = true;\r\n        }\r\n        else {\r\n            // Append unmatch characters\r\n            // formattedStr += strChar; // NOTE: This line appears to be useless, and generates warning -Russ\r\n\r\n            score += unmatched_letter_penalty;\r\n            prevMatched = false;\r\n        }\r\n\r\n        // Includes \"clever\" isLetter check.\r\n        prevLower = strChar === strLower && strLower !== strUpper;\r\n        prevSeparator = strChar === '_' || strChar === ' ';\r\n\r\n        ++strIdx;\r\n    }\r\n\r\n    // Apply score for last match\r\n    if (bestLetter) {\r\n        score += bestLetterScore;\r\n        matchedIndices.push(bestLetterIdx);\r\n    }\r\n\r\n    // Finish out formatted string after last pattern matched\r\n    // Build formated string based on matched letters\r\n    var formattedStr = \"\";\r\n    var lastIdx = 0;\r\n    for (var i = 0; i < matchedIndices.length; ++i) {\r\n        var idx = matchedIndices[i];\r\n        formattedStr += str.substr(lastIdx, idx - lastIdx) + \"<b>\" + str.charAt(idx) + \"</b>\";\r\n        lastIdx = idx + 1;\r\n    }\r\n    formattedStr += str.substr(lastIdx, str.length - lastIdx);\r\n\r\n    var matched = patternIdx === patternLength;\r\n    return [matched, score, formattedStr];\r\n}\r\n\r\n\r\n// Strictly optional utility to help make using fts_fuzzy_match easier for large data sets\r\n// Uses setTimeout to process matches before a maximum amount of time before sleeping\r\n//\r\n// To use:\r\n//      var asyncMatcher = new fts_fuzzy_match(fuzzy_match, \"fts\", \"ForrestTheWoods\",\r\n//                                              function(results) { console.log(results); });\r\n//      asyncMatcher.start();\r\n//\r\nexport function fts_fuzzy_match_async(matchFn, pattern, dataSet, onComplete) {\r\n    var ITEMS_PER_CHECK = 1000;         // performance.now can be very slow depending on platform\r\n\r\n    var max_ms_per_frame = 1000.0/30.0; // 30FPS\r\n    var dataIndex = 0;\r\n    var results = [];\r\n    var resumeTimeout = null;\r\n\r\n    // Perform matches for at most max_ms\r\n    function step() {\r\n        clearTimeout(resumeTimeout);\r\n        resumeTimeout = null;\r\n\r\n        var stopTime = performance.now() + max_ms_per_frame;\r\n\r\n        for (; dataIndex < dataSet.length; ++dataIndex) {\r\n            if ((dataIndex % ITEMS_PER_CHECK) === 0) {\r\n                if (performance.now() > stopTime) {\r\n                    resumeTimeout = setTimeout(step, 1);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            var str = dataSet[dataIndex];\r\n            var result = matchFn(pattern, str);\r\n\r\n            // A little gross because fuzzy_match_simple and fuzzy_match return different things\r\n            if (matchFn === fuzzy_match_simple && result === true)\r\n                results.push(str);\r\n            else if (matchFn === fuzzy_match && result[0] === true)\r\n                results.push(result);\r\n        }\r\n\r\n        onComplete(results);\r\n        return null;\r\n    };\r\n\r\n    // Abort current process\r\n    this.cancel = function() {\r\n        if (resumeTimeout !== null)\r\n            clearTimeout(resumeTimeout);\r\n    };\r\n\r\n    // Must be called to start matching.\r\n    // I tried to make asyncMatcher auto-start via \"var resumeTimeout = step();\"\r\n    // However setTimout behaving in an unexpected fashion as onComplete insisted on triggering twice.\r\n    this.start = function() {\r\n        step();\r\n    }\r\n\r\n    // Process full list. Blocks script execution until complete\r\n    this.flush = function() {\r\n        max_ms_per_frame = Infinity;\r\n        step();\r\n    }\r\n};\r\n","import React, { useState, useEffect, useRef } from 'react';\nimport './ExpressionChooser.css';\nimport { fuzzy_match } from './vendor/fts_fuzzy_match';\nimport genuid from './uid';\nimport { environmentForSelectedNode } from './EditReducer';\n\nfunction fuzzySearch(query, items) {\n  const results = [];\n\n  for (const [name, data] of items) {\n    const [hit, score, formattedStr] = fuzzy_match(query, name);\n    if (hit) {\n      results.push({\n        score,\n        formattedStr,\n        name,\n        data,\n      });\n    }\n  }\n  if (query !== '') { // TODO: this is a hack, is query is empty, scoring is dumb\n    results.sort((a, b) => (b.score - a.score));\n  }\n  return results;\n}\n\nconst FLOAT_REGEX = /^[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?$/;\n\nfunction generateChoices(text, mainState) {\n  const choices = [];\n\n  // If there is no text, put this first as a sort of default\n  if (text === '') {\n    choices.push({\n      type: 'undefined',\n    });\n  }\n\n  const { namedStreams, namedFunctions } = environmentForSelectedNode(mainState);\n\n  const streamSearchResults = fuzzySearch(text, namedStreams);\n  for (const result of streamSearchResults) {\n    choices.push({\n      type: 'streamref',\n      node: result.data,\n    });\n  }\n\n  const functionSearchResults = fuzzySearch(text, namedFunctions);\n  for (const result of functionSearchResults) {\n    choices.push({\n      type: 'function',\n      node: result.data,\n    });\n  }\n\n  if (FLOAT_REGEX.test(text)) {\n    choices.push({\n      type: 'number',\n      value: Number(text),\n    });\n  }\n\n  if (choices.length === 0) {\n    choices.push({\n      type: 'undefined',\n    });\n  }\n\n  return choices;\n}\n\nfunction Choice({ choice }) {\n  switch (choice.type) {\n    case 'undefined':\n      return <em>undefined</em>\n\n    case 'number':\n      return <span>{choice.value}</span>\n\n    case 'streamref':\n      return <span><em>S</em> {choice.node.identifier.name} <small>(id {choice.node.streamId})</small></span>\n\n    case 'function':\n      return <span><em>F</em> {choice.node.identifier.name}({[].concat([\n        choice.node.signature.parameters.map(n => (n.startsWith('_') ? '\\u25A1' : n)), // parameters\n        choice.node.signature.functionParameters.map(([n, ]) => 'F ' + ((n.startsWith('_') ? '\\u25A1' : n))), // function parameters\n      ]).join(', ')})</span>\n\n    default:\n      throw new Error();\n  }\n}\n\nexport default function ExpressionChooser({ node, mainState, dispatch }) {\n  const selectedListElem = useRef();\n  useEffect(() => {\n    if (selectedListElem.current) {\n      selectedListElem.current.scrollIntoView({block: 'nearest', inline: 'nearest'});\n    }\n  });\n\n  const [text, setText] = useState(() => {\n    const initFromNode = mainState.editingSelected.tentativeNode;\n\n    // Initialize text based on node\n    switch (initFromNode.type) {\n      case 'UndefinedExpression':\n        return '';\n\n      case 'IntegerLiteral':\n        return initFromNode.value.toString();\n\n      case 'StreamReference':\n      case 'Application':\n        return ''; // Don't prefill with text, but in case we change our mind, old code is below\n/*\n      case 'StreamReference': {\n        const targetExpressionNode = mainState.derivedLookups.streamIdToNode.get(initFromNode.targetStreamId);\n        return targetExpressionNode.identifier ? targetExpressionNode.identifier.name : '';\n      }\n\n      case 'Application': {\n        const functionNode = mainState.derivedLookups.functionIdToNode.get(initFromNode.functionId);\n        return functionNode.identifier ? functionNode.identifier.name : '';\n      }\n*/\n\n      default:\n        throw new Error();\n    }\n  });\n\n  // Update the expression node to reflect the current choice\n  const realizeChoice = (state) => {\n    const choice = state.choices[state.index];\n\n    let newNode;\n    switch (choice.type) {\n      case 'undefined':\n        newNode = {\n          type: 'UndefinedExpression',\n        }\n        break;\n\n      case 'number':\n        newNode = {\n          type: 'IntegerLiteral',\n          value: choice.value,\n        };\n        break;\n\n      case 'streamref':\n        newNode = {\n          type: 'StreamReference',\n          targetStreamId: choice.node.streamId,\n        };\n        break;\n\n      case 'function':\n        newNode = {\n          type: 'Application',\n          functionId: choice.node.functionId,\n          arguments: choice.node.signature.parameters.map(paramName => ({\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          })),\n          functionArguments: choice.node.signature.functionParameters.map(([, signature]) => ({\n            type: 'UserFunction',\n            functionId: genuid(),\n            identifier: null,\n            signature, // TODO: do we need to defensively copy this?\n            parameters: signature.parameters.map(pn => ({\n              type: 'Parameter',\n              streamId: genuid(),\n              identifier: {\n                type: 'Identifier',\n                name: pn,\n              },\n            })),\n            functionParameterFunctionIds: signature.functionParameters.map(([pn, sig]) => genuid()),\n            expressions: [\n              {\n                type: 'UndefinedExpression',\n                streamId: genuid(),\n                identifier: null,\n              },\n            ],\n          })),\n        };\n        break;\n\n      default:\n        throw new Error();\n    }\n\n    newNode.streamId = mainState.editingSelected.tentativeNode.streamId;\n    newNode.identifier = mainState.editingSelected.tentativeNode.identifier;\n\n    dispatch({type: 'UPDATE_EDITING_TENTATIVE_NODE', newNode});\n  };\n\n  const recomputeDropdownChoices = (text) => {\n    const newState = {\n      choices: generateChoices(text, mainState),\n      index: 0, // reset index to 0\n    };\n    realizeChoice(newState);\n    return newState;\n  };\n\n  const adjustDropdownIndex = (amount) => {\n    setDropdownState(oldState => {\n      const newState = {\n        ...oldState,\n        index: (oldState.index + amount + oldState.choices.length) % oldState.choices.length,\n      };\n      realizeChoice(newState);\n      return newState;\n    });\n  };\n\n  const [dropdownState, setDropdownState] = useState(() => recomputeDropdownChoices(text));\n\n  const onChange = e => {\n    const newText = e.target.value;\n\n    if (newText === '[') {\n      // This is a special case, we bypass the normal dropdown/choice stuff\n      dispatch({type: 'END_EXPRESSION_EDIT'});\n      dispatch({type: 'CREATE_ARRAY'});\n    } else {\n      setText(newText);\n      setDropdownState(recomputeDropdownChoices(newText));\n    }\n  };\n\n  const onKeyDown = e => {\n    switch (e.key) {\n      case 'ArrowUp':\n        e.preventDefault(); // we don't want the default behavior of moving the cursor\n        adjustDropdownIndex(-1);\n        break;\n\n      case 'ArrowDown':\n        e.preventDefault(); // we don't want the default behavior of moving the cursor\n        adjustDropdownIndex(1);\n        break;\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n  return (\n    <div>\n      <input className=\"Editor-text-edit-input\" value={text} onChange={onChange} onKeyDown={onKeyDown} autoFocus />\n      <ul className=\"ExpressionChooser-dropdown\">\n        {dropdownState.choices.map((choice, idx) =>\n          <li key={idx} className={(idx === dropdownState.index) ? 'ExpressionChooser-dropdown-selected' : ''} ref={(idx === dropdownState.index) ? selectedListElem : undefined}><Choice choice={choice} /></li>\n        )}\n      </ul>\n    </div>\n  );\n}\n","import React, { useState, useEffect, useRef } from 'react';\nimport genuid from './uid';\nimport './StoragePanel.css';\n\nexport default function StoragePanel({ currentProgram, onChangeName, onLoadProgram }) {\n  const ls = window.localStorage;\n  const KEY_PREFIX = 'rivprog:';\n\n  const [selectedProgramId, setSelectedProgramId] = useState();\n  const [savedPrograms, setSavedPrograms] = useState([]);\n\n  const refreshSavedPrograms = (setProgramId) => {\n    let newProgramId = setProgramId === undefined ? selectedProgramId : setProgramId;\n\n    const sp = [];\n    for (let i = 0; i < ls.length; i++) {\n      const k = ls.key(i);\n      if (k.startsWith(KEY_PREFIX)) {\n        const obj = JSON.parse(ls.getItem(k));\n        sp.push(obj);\n      }\n    }\n    setSavedPrograms(sp);\n\n    const savedProgramIds = sp.map(prog => prog.id);\n    if (!savedProgramIds.includes(newProgramId)) {\n      newProgramId = undefined;\n    }\n\n    setSelectedProgramId(newProgramId);\n  };\n\n  useEffect(() => {\n    refreshSavedPrograms();\n  }, []);\n\n  const handleChangeName = (e) => {\n    if (onChangeName) {\n      onChangeName(e.target.value);\n    }\n  };\n\n  const handleSave = () => {\n    const k = KEY_PREFIX + currentProgram.id;\n    const json = JSON.stringify(currentProgram);\n    ls.setItem(k, json);\n    refreshSavedPrograms(currentProgram.id);\n  };\n\n  const handleClone = () => {\n    onLoadProgram({\n      ...currentProgram,\n      id: genuid(),\n    });\n  };\n\n  const selectRef = useRef();\n  const handleSetProgramId = (e) => {\n    setSelectedProgramId(e.target.value);\n  };\n\n  const handleLoad = () => {\n    if (selectRef.current && selectRef.current.value) {\n      const k = KEY_PREFIX + selectRef.current.value;\n      const obj = JSON.parse(ls.getItem(k));\n      onLoadProgram(obj);\n    }\n  };\n\n  const handleDelete = () => {\n    if (selectRef.current && selectRef.current.value) {\n      const k = KEY_PREFIX + selectRef.current.value;\n      ls.removeItem(k);\n      refreshSavedPrograms();\n    }\n  };\n\n  return (\n    <div className=\"StoragePanel\">\n      <div>\n        <span>Current Program:</span>{' '}\n        <label>UID: <span>{currentProgram.id}</span></label>{' '}\n        <label>Name: <input value={currentProgram.name} onChange={handleChangeName} /></label>{' '}\n        <button onClick={handleSave}>Save</button>{' '}\n        <button onClick={handleClone}>Clone</button>{' '}\n        <button disabled>Import</button>{' '}\n        <button disabled>Export</button>{' '}\n      </div>\n      <div>\n        <span>Saved Programs:</span>{' '}\n        <select ref={selectRef} value={selectedProgramId} onChange={handleSetProgramId}>{savedPrograms.map((prog) => (\n          <option key={prog.id} value={prog.id}>{prog.name} &lt;{prog.id}&gt;</option>\n        ))}\n        </select>{' '}\n        <button onClick={handleLoad} disabled={savedPrograms.length === 0}>Load</button>{' '}\n        <button onClick={handleDelete} disabled={savedPrograms.length === 0}>Delete</button>{' '}\n      </div>\n    </div>\n  )\n}\n","import React, { useState } from 'react';\nimport './Simple.css';\n\nfunction Selectable({ marks, onSelect, onEdit, children, extraClassName }) {\n  const [hovered, setHovered] = useState(false);\n\n  let className = extraClassName || '';\n  className += ' SimpleTheme-selectable';\n  if (marks.includes('selected')) {\n    className += ' SimpleTheme-selected';\n  } else if (hovered) {\n    className += ' SimpleTheme-hovered';\n  } else if (marks.includes('clipboard-top')) {\n    className += ' SimpleTheme-clipboard-top';\n  } else if (marks.includes('clipboard-rest')) {\n    className += ' SimpleTheme-clipboard-rest';\n  }\n\n  const handleClick = (e) => {\n    if (onSelect && (e.target.tagName !== 'INPUT')) {\n      e.stopPropagation();\n      onSelect();\n    }\n  };\n\n  const handleDoubleClick = (e) => {\n    if (onEdit && (e.target.tagName !== 'INPUT')) {\n      e.stopPropagation();\n      onEdit();\n    }\n  };\n\n  const handleMouseOver = (e) => {\n    setHovered(true);\n    e.stopPropagation();\n  };\n\n  const handleMouseOut = (e) => {\n    setHovered(false);\n  };\n\n  return (\n    <div className={className} onClick={handleClick} onDoubleClick={handleDoubleClick} onMouseOver={handleMouseOver} onMouseOut={handleMouseOut}>\n      {children}\n    </div>\n  );\n}\n\nexport const generateTheme = ({ expressionGrouping, applicationArguments }) => ({\n  Application: ({ functionName, streamArgs, functionArgs }) => {\n    const appClass = ((applicationArguments === 'right') || (applicationArguments === 'right-centered')) ? 'SimpleTheme-application-flex' : '';\n    const nameClass = 'SimpleTheme-application-function-name' + ((applicationArguments === 'right-centered') ? ' SimpleTheme-application-function-name-centered' : '');\n    return (\n      <div className={appClass}>\n        <div className={nameClass}>{functionName}</div>\n        <div className=\"SimpleTheme-application-arguments\">\n          {streamArgs.map(({key, name, expression}) => (\n            <div className=\"SimpleTheme-application-argument\" key={key}>{name ? <span className=\"SimpleTheme-application-argument-name\">{name}:</span> : null}<span className=\"SimpleTheme-application-argument-expression\">{expression}</span></div>\n          ))}\n          {functionArgs.map(({key, name, functionExpression}) => (\n            <div className=\"SimpleTheme-application-argument\" key={key}>{functionExpression}</div>\n          ))}\n        </div>\n      </div>\n    );\n  },\n\n  UserFunction: ({ parameterNames, expressions, marks, onSelect }) => (\n    <Selectable marks={marks} onSelect={onSelect} extraClassName={'SimpleTheme-user-function'}>\n      <div> {parameterNames.join(', ')}</div>\n      <div className=\"SimpleTheme-user-function-expressions\">{expressions}</div>\n    </Selectable>\n  ),\n\n  DefinitionExpression: ({ expression }) => (\n    <div className=\"SimpleTheme-definition-expression\">{expression}</div>\n  ),\n\n  Expression: ({ identifier, marks, onSelect, onEdit, inside }) => {\n    let exprClass = 'SimpleTheme-expression';\n\n    switch (expressionGrouping) {\n      case 'background':\n        exprClass += ' SimpleTheme-expression-background';\n        break;\n\n      case 'shadow':\n        exprClass += ' SimpleTheme-expression-shadow';\n        break;\n\n      default:\n        // ignore\n        break;\n    }\n\n    return (\n      <Selectable marks={marks} onSelect={onSelect} onEdit={onEdit} extraClassName={exprClass}>\n        { (() => {\n          switch (expressionGrouping) {\n            case 'line':\n              return (\n                <div className=\"SimpleTheme-expression-line\" />\n              );\n\n            case 'bracket':\n              return (\n                <div className=\"SimpleTheme-expression-bracket\" />\n              );\n\n            default:\n              return null;\n          }\n        })() }\n        <div>\n          {identifier ? <div className=\"SimpleTheme-expression-identifier\">{identifier}</div> : null}\n          <div className=\"SimpleTheme-expression-main\">{inside}</div>\n        </div>\n      </Selectable>\n    );\n  },\n\n  Identifier: ({ marks, onSelect, inside }) => (\n    <Selectable marks={marks} onSelect={onSelect} extraClassName={'SimpleTheme-identifier'}>{inside}</Selectable>\n  ),\n\n  StreamReference: ({ name }) => (\n    <div><span className=\"SimpleTheme-stream-reference\">{name}</span></div>\n  ),\n\n  UndefinedExpression: () => (\n    <div className=\"SimpleTheme-undefined-expression\">&nbsp;</div>\n  ),\n\n  ArrayLiteral: ({ keyedItems }) => (\n    <div>\n      <div>[</div>\n      <div className=\"SimpleTheme-array-items\">\n        {keyedItems.map(([key, item]) => (\n          <div className=\"SimpleTheme-array-item\" key={key}>{item}</div>\n        ))}\n      </div>\n      <div>]</div>\n    </div>\n  ),\n});\n","import React, { useState } from 'react';\nimport { generateTheme } from './themes/Simple';\nimport './ThemePicker.css';\n\nconst INITIAL_OPTIONS = {\n  expressionGrouping: 'background',\n  applicationArguments: 'right',\n};\n\nexport const INITIAL_THEME = generateTheme(INITIAL_OPTIONS);\n\nfunction Select({ keyLabels, selectedKey, onChange }) {\n  return (\n    <select value={selectedKey} onChange={evt => { onChange(evt.target.value) }}>\n      {keyLabels.map(([key, label]) => <option key={key} value={key}>{label}</option>)}\n    </select>\n  )\n}\n\nexport function ThemePicker({ onChange }) {\n  const [options, setOptions] = useState(INITIAL_OPTIONS);\n\n  const update = (newOptions) => {\n    setOptions(newOptions);\n    onChange(generateTheme(newOptions));\n  };\n\n  return (\n    <div className=\"ThemePicker\">\n      <div className=\"ThemePicker-option\"><label>Expression Grouping: <Select keyLabels={[\n        ['none', 'None'],\n        ['line', 'Line'],\n        ['bracket', 'Bracket'],\n        ['background', 'Background'],\n        ['shadow', 'Shadow'],\n      ]} selectedKey={options.expressionGrouping} onChange={v => update({ ...options, expressionGrouping: v })} /></label></div>\n      <div className=\"ThemePicker-option\"><label>Application Arguments: <Select keyLabels={[\n        ['below', 'Below'],\n        ['right', 'Right'],\n        ['right-centered', 'Right (centered)'],\n      ]} selectedKey={options.applicationArguments} onChange={v => update({ ...options, applicationArguments: v })} /></label></div>\n    </div>\n  );\n}\n\n/*\n<label>Theme:\n            <select value={theme} onChange={evt => { setTheme(evt.target.value) }}>{THEMES.map(([name, ]) => <option key={name} value={name}>{name}</option>)}</select>\n          </label>\n*/\n","import React, { createContext, useContext, useReducer, useRef, useEffect, useState } from 'react';\nimport { HotKeys, ObserveKeys } from \"react-hotkeys\";\nimport { initialState, reducer, nodeFromPath } from './EditReducer';\nimport ExpressionChooser from './ExpressionChooser';\nimport StoragePanel from './StoragePanel';\nimport { INITIAL_THEME, ThemePicker } from './ThemePicker';\nimport './Editor.css';\n\nconst keyMap = {\n  MOVE_UP: 'up',\n  MOVE_DOWN: 'down',\n  MOVE_LEFT: 'left',\n  MOVE_RIGHT: 'right',\n\n  ZOOM_IN: 'shift+right',\n  ZOOM_OUT: 'shift+left',\n\n  TOGGLE_EDIT: 'enter',\n  ABORT_EDIT: 'escape',\n\n  EDIT_AFTER: ['shift+enter', ','],\n\n  DELETE: 'backspace',\n\n  BEGIN_IDENTIFIER_EDIT: '=',\n\n  EDIT_NEXT_UNDEFINED: 'tab',\n\n  UNDO: 'command+z',\n\n  CUT: 'command+x',\n  PASTE: 'command+v',\n};\n\n// These are \"normal\" character keys that we use as commands. We identify them because we don't want\n// them to begin a \"overwrite edit\".\nconst COMMAND_CHARS = new Set([\n  '=',\n  ',',\n]);\n\n// By default, if an input element is focused, keys will be ignored. But we want some\n// of them to be processed even when an input is focused, and those ones are listed here.\n// Note that react-hotkeys only lets us list the individual keys here not \"combinations\"\n// as we would want.\nconst CATCH_IN_INPUTS = [\n  'Enter',\n  'Shift',\n  'Escape',\n  'Tab',\n  '=',\n  ',',\n];\n\nconst FullStateContext = createContext();\n\nconst DispatchContext = createContext();\n\nconst MarkedNodesContext = createContext();\nfunction useMarks(obj) {\n  const marks = [];\n  const { selectedNode, clipboardTopNode, clipboardRestNodes } = useContext(MarkedNodesContext);\n  if (obj === selectedNode) {\n    marks.push('selected');\n  }\n  if (obj === clipboardTopNode) {\n    marks.push('clipboard-top');\n  }\n  if (clipboardRestNodes.includes(obj)) {\n    marks.push('clipboard-rest');\n  }\n  return marks;\n}\nfunction useHandleSelect(obj) {\n  const dispatch = useContext(DispatchContext);\n  const state = useContext(FullStateContext);\n\n  return () => {\n    const path = state.derivedLookups.nodeToPath.get(obj);\n    if (path) {\n      dispatch({\n        type: 'SET_PATH',\n        newPath: path,\n      });\n    }\n  };\n}\nfunction useHandleEdit(obj) {\n  const dispatch = useContext(DispatchContext);\n  const state = useContext(FullStateContext);\n\n  return () => {\n    const path = state.derivedLookups.nodeToPath.get(obj);\n    if (path) {\n      dispatch({\n        type: 'SET_PATH',\n        newPath: path,\n      });\n      dispatch({\n        type: 'TOGGLE_EDIT',\n      });\n    }\n  };\n}\n\n\nconst ThemeContext = createContext();\n\nfunction DefinitionExpressionsView({ expressions }) {\n  const { DefinitionExpression } = useContext(ThemeContext);\n\n  return (\n    <>\n      {expressions.map((expression) => (\n        <div key={expression.streamId}>\n          <DefinitionExpression expression={<ExpressionView expression={expression} />} />\n        </div>\n      ))}\n    </>\n  )\n}\n\nfunction IdentifierChooser({ initialName, onUpdateName, onEndEdit }) {\n  const [text, setText] = useState(initialName || '');\n\n  const handleChange = e => {\n    const newText = e.target.value;\n    setText(newText);\n    if (onUpdateName) {\n      onUpdateName(newText);\n    }\n  };\n\n  return <input className=\"Editor-text-edit-input\" value={text} onChange={handleChange} autoFocus />;\n}\n\nfunction IdentifierView({ identifier }) {\n  const marks = useMarks(identifier);\n  const handleSelect = useHandleSelect(identifier);\n  const {editingSelected} = useContext(FullStateContext);\n  const dispatch = useContext(DispatchContext);\n\n  const handleUpdateName = (name) => {\n    dispatch({\n      type: 'UPDATE_EDITING_TENTATIVE_NODE',\n      newNode: {\n        type: 'Identifier',\n        name,\n      },\n    });\n  };\n\n  const { Identifier } = useContext(ThemeContext);\n\n  return <Identifier marks={marks} onSelect={handleSelect} inside={(marks.includes('selected') && editingSelected)\n    ? <IdentifierChooser initialName={identifier.name} onUpdateName={handleUpdateName} />\n    : identifier.name\n  } />;\n}\n\nfunction IntegerLiteralView({ integerLiteral }) {\n  return <div>{integerLiteral.value}</div>;\n}\n\nfunction ArrayLiteralView({ arrayLiteral }) {\n  const { ArrayLiteral } = useContext(ThemeContext);\n\nreturn <ArrayLiteral keyedItems={arrayLiteral.items.map(item => [item.streamId, <ExpressionView expression={item} />])} />\n}\n\nfunction UndefinedExpressionView({ undefinedExpression }) {\n  const { UndefinedExpression } = useContext(ThemeContext);\n  return <UndefinedExpression />\n}\n\nfunction StreamReferenceView({ streamReference }) {\n  const {streamIdToNode} = useContext(FullStateContext).derivedLookups;\n  const targetExpressionNode = streamIdToNode.get(streamReference.targetStreamId);\n  if (!targetExpressionNode) {\n    throw new Error();\n  }\n\n  const { StreamReference } = useContext(ThemeContext);\n  return <StreamReference name={(targetExpressionNode.identifier && targetExpressionNode.identifier.name) ? targetExpressionNode.identifier.name : '<stream ' + streamReference.targetStreamId + '>'} />;\n}\n\nfunction UserFunctionView({ userFunction }) {\n  const marks = useMarks(userFunction);\n  const handleSelect = useHandleSelect(userFunction);\n  const { UserFunction } = useContext(ThemeContext);\n\n  return (\n    <UserFunction parameterNames={userFunction.parameters.map(param => param.identifier.name)} expressions={<DefinitionExpressionsView expressions={userFunction.expressions} />} marks={marks} onSelect={handleSelect} />\n  );\n}\n\nfunction ApplicationView({ application }) {\n  const {functionIdToNode} = useContext(FullStateContext).derivedLookups;\n  const functionNode = functionIdToNode.get(application.functionId);\n  if (!functionNode) {\n    throw new Error();\n  }\n\n  if (functionNode.signature.parameters.length !== application.arguments.length) {\n    throw new Error('params and args length mismatch');\n  }\n\n  if (functionNode.signature.functionParameters.length !== application.functionArguments.length) {\n    throw new Error('function params and args length mismatch');\n  }\n\n  const functionName = (functionNode.identifier && functionNode.identifier.name) ? functionNode.identifier.name : '<function ' + application.functionId + '>';\n  const streamArgs = functionNode.signature.parameters.map((paramName, idx) => ({\n    key: paramName,\n    name: paramName.startsWith('_') ? undefined : paramName,\n    expression: <ExpressionView expression={application.arguments[idx]} />\n  }));\n  const functionArgs = functionNode.signature.functionParameters.map(([paramName, signature], idx) => ({\n    key: paramName,\n    name: 'dunno',\n    functionExpression: <UserFunctionView userFunction={application.functionArguments[idx]} />\n  }));\n\n  const { Application } = useContext(ThemeContext);\n\n  return <Application functionName={functionName} streamArgs={streamArgs} functionArgs={functionArgs} />;\n}\n\nfunction NotEditingExpressionView({ expression }) {\n  switch (expression.type) {\n    case 'IntegerLiteral':\n      return <IntegerLiteralView integerLiteral={expression} />\n\n    case 'ArrayLiteral':\n      return <ArrayLiteralView arrayLiteral={expression} />\n\n    case 'UndefinedExpression':\n      return <UndefinedExpressionView undefinedExpression={expression} />\n\n    case 'StreamReference':\n      return <StreamReferenceView streamReference={expression} />\n\n    case 'Application':\n      return <ApplicationView application={expression} />\n\n    default:\n      throw new Error();\n  }\n}\n\nfunction ExpressionView({ expression }) {\n  const marks = useMarks(expression);\n  const handleSelect = useHandleSelect(expression);\n  const handleEdit = useHandleEdit(expression);\n  const mainState = useContext(FullStateContext);\n  const editingSelected = mainState.editingSelected;\n  const dispatch = useContext(DispatchContext);\n  const { Expression } = useContext(ThemeContext);\n\n  return <Expression identifier={expression.identifier ? <IdentifierView identifier={expression.identifier} /> : null} marks={marks} onSelect={handleSelect} onEdit={handleEdit} inside={\n    (marks.includes('selected') && editingSelected)\n      ? <ExpressionChooser node={expression} mainState={mainState} dispatch={dispatch} />\n      : <NotEditingExpressionView expression={expression} />\n  } />;\n}\n\nexport default function Editor({ autoFocus }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const [theme, setTheme] = useState(INITIAL_THEME);\n\n  const editorElem = useRef();\n\n  // Do auto-focus if prop is set\n  const [constAutoFocus] = useState(autoFocus);\n  useEffect(() => {\n    if (constAutoFocus) {\n      // Focus editor after initial render\n      editorElem.current.focus();\n    }\n  }, [constAutoFocus]);\n\n  // Restore focus to editor elem if input box just went away.\n  // NOTE: This is hacky, but don't know better way to handle.\n  const previouslyEditingSelected = useRef(false);\n  useEffect(() => {\n    if (previouslyEditingSelected.current && !state.editingSelected) {\n      editorElem.current.focus();\n    }\n    previouslyEditingSelected.current = state.editingSelected;\n  });\n\n  // TODO: memoize generation of this\n  const handlers = {};\n  for (const k of Object.keys(keyMap)) {\n    handlers[k] = (() => (e) => {\n      e.preventDefault(); // If we attempted to handle this, prevent default (scrolling window, entering character, etc.)\n      dispatch({type: k});\n    })(); // IIFE to bind k\n  }\n\n  const onKeyDown = e => {\n    // TODO: This is not a robust check, but the spec is complicated\n    // (https://www.w3.org/TR/uievents-key/#keys-whitespace)\n    if ((e.target.tagName.toLowerCase() !== 'input') && ([...e.key].length === 1) && !e.altkey && !e.ctrlKey && !e.metaKey && !COMMAND_CHARS.has(e.key)) {\n      // Interestingly, the key here will still end up going into the input element, which is what we want.\n      dispatch({type: 'BEGIN_OVERWRITE_EDIT'});\n    }\n  };\n\n  const markedNodes = {\n    selectedNode: nodeFromPath(state.program, state.selectionPath),\n    clipboardTopNode: (state.clipboardStack.length > 0) ? state.derivedLookups.streamIdToNode.get(state.clipboardStack[state.clipboardStack.length-1].streamId) : null,\n    clipboardRestNodes: state.clipboardStack.slice(0, -1).map(frame => state.derivedLookups.streamIdToNode.get(frame.streamId)),\n  }\n\n  const handleChangeProgramName = (newName) => {\n    dispatch({type: 'SET_PROGRAM_NAME', newName});\n  };\n\n  const handleLoadProgram = (program) => {\n    dispatch({type: 'LOAD_PROGRAM', program});\n  };\n\n  return (\n    <div className=\"Editor\">\n      <HotKeys keyMap={keyMap} handlers={handlers}>\n        <ObserveKeys only={CATCH_IN_INPUTS}>\n          <div className=\"Editor-workspace\" onKeyDown={onKeyDown} tabIndex=\"0\" ref={editorElem}>\n            <div className=\"Editor-theme-controls\"><ThemePicker onChange={newTheme => { setTheme(newTheme) }} /></div>\n            <DispatchContext.Provider value={dispatch}>\n              <MarkedNodesContext.Provider value={markedNodes}>\n                <FullStateContext.Provider value={state}>\n                  <ThemeContext.Provider value={theme}>\n                    <UserFunctionView userFunction={state.program.mainDefinition} />\n                  </ThemeContext.Provider>\n                </FullStateContext.Provider>\n              </MarkedNodesContext.Provider>\n            </DispatchContext.Provider>\n          </div>\n        </ObserveKeys>\n      </HotKeys>\n      <div className=\"Editor-storage-panel-container\">\n        <StoragePanel currentProgram={state.program} onChangeName={handleChangeProgramName} onLoadProgram={handleLoadProgram} />\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport Editor from './Editor';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Editor autoFocus={true} />\n      <div>\n        <h2>Notes</h2>\n        <ul>\n          <li>If you don't see a green selection/cursor box, focus the editor.</li>\n          <li>The mouse can be used to select parts of the tree, but otherwise editing is keyboard-driven.</li>\n          <li>Up/down arrows move selection up and down within lists (expressions, arguments, arrays).</li>\n          <li>Right/left arrows move selection in and out of nested structures.</li>\n          <li>Enter on an expression (or expression sub-tree) will begin editing it. Pressing enter again will stop editing.</li>\n          <li>Instead of pressing enter, you can just start typing letters/numbers and it will begin the edit (overwriting what it there).</li>\n          <li>Escape aborts the current edit.</li>\n          <li>Shift-enter (or comma) adds a new expression (or array item) below the current one.</li>\n          <li>Pressing the = key on on an expression will move to editing its name/label.</li>\n          <li>A red box indicates an undefined expression.</li>\n          <li>Tab edits the next undefined expression.</li>\n          <li>Delete will delete expressions, array items, etc.</li>\n          <li>Typing [ when editing an expression will create an array literal.</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}